---
title: Principles of Computer Composition
date: 2019-11-17
categories:
   - 经纶·注
tags:
   - CS
   - kaoyan
---

::: warning ♻️ Reviewing

《计算机组成原理》复习笔记

:::

<!-- more -->

## 1 计算机系统概述

### 1.1 计算机发展历程

#### 1.1.1 计算机硬件的发展

-  计算机的四代变化

   -  第一代计算机 电子管时代
   -  第二代计算机 晶体管时代
   -  第三代计算机 中小规模集成电路时代
   -  第四代计算机 超大规模集成电路时代

-  计算机元件的更新换代

   -  摩尔定律 当价格不变时，集成电路上可容纳的晶体管数目，约每隔 18 个月便会增加一倍，性能也将提升一倍
   -  半导体存储期的发展 单芯片 1KB 到现在的 GB 级
   -  微处理器的发展 8 位到现在的 64 位（机器字长）

#### 1.1.2 计算机软件的发展

-  机器语言 面向机器
-  汇编语言 面向机器
-  高级语言 面向问题
   -  FORTRAN 科学计算和工程计算
   -  PASCAL 结构化程序设计
   -  C++ 面向对象
   -  Java 适应网络环境

### 1.2 计算机系统层次结构

#### 1.2.1 计算机系统的组成

通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率，而用软件实现可以提高灵活性，但效率往往不如硬件实现高

#### 1.2.2 计算机硬件的基本组成

计算机硬件系统由**运算器**、**存储器**、**控制器**、**输入设备**和**输出设备** 5 大部件组成

-  早期的冯·诺依曼计算机

   ![PCC01.png{copyright:Wangdao}](../Images/PCC01.png)

   -  特点

      -  计算机由**五大部件**组成
      -  指令和数据以**同等地位**存于存储器，可按地址寻访
      -  指令和数据用二进制表示
      -  指令由**操作码**和**地址码**组成
      -  指令在存储器内**按顺序存放**
      -  以运算器为中心

-  现代计算机的组织结构

   以存储器为中心，使 I/O 操作尽可能地绕过 CPU ，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率

   ![PCC02.png{copyright:Wangdao}](../Images/PCC02.png)

-  计算机的功能部件

   -  输入设备 将信息转换成机器能识别的形式
   -  输出设备 将结果转换成人们熟悉的形式
   -  存储器 用来存放程序和数据

      -  主存储器

         -  存储体 存放二进制信息
         -  地址寄存器 MAR 存放访存地址，经过地址译码后找到所选的存储单元

            由于其用于寻址，所以其位数对应着存储单元的个数，与 PC 位数相等

         -  数据寄存器 MDR 主存和其他部件的中介机构，用于暂存要从存储器读或写的信息

            MDR 的位数和存储字长相等，一般为字节的二次幂倍

      -  辅助存储器

   -  运算器 完成算术运算和逻辑运算

      -  算数逻辑单元 ALU
      -  若干通用寄存器
         -  累加器 ACC
         -  乘商寄存器 MQ
         -  操作数寄存器 X
         -  变址寄存器 IX
         -  基址寄存器 BR
         -  程序状态寄存器 PSW

   -  控制器 指挥各部件自动协调地进行工作

      -  程序计数器 PC 用来存放当前欲执行指令的地址，可以自动加一以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路
      -  指令寄存器 IR 用来存放当前的指令，其内容来自主存的 MDR

   ![PCC03.png{copyright:Wangdao}](../Images/PCC03.png)

   主机包含 CPU 和主存，其他的硬件装置统称外设，主要为外存和 I/O 设备

   另外，现代计算机的 CPU 通常还集成了 Cache 、 MAR 、MDR ，而不是在主存里

#### 1.2.3 计算机软件的分类

-  系统软件
   -  操作系统（OS）
   -  数据库管理系统（DBMS）
   -  语言处理程序
   -  分布式软件系统
   -  ……
-  应用软件 按任务需要编制成的各种程序

#### 1.2.4 计算机的工作过程

1. 把程序和数据装入主存储器
2. 从程序的起始地址运行程序
3. 用程序的首地址从存储器中取出第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成这条指令功能，并计算下一条指令的地址
4. 用新得到的指令地址继续当初第二条指令并执行，直到程序结束为止；每条指令都是在**取指、译码和执行**的循环过程中完成的

以取数指令为例

-  ==取指==： PC $\to$ MAR $\to$ M $\to$ MDR $\to$ IR
-  ==分析==： OP(IR) $\to$ CU
-  ==执行==： Ad(IR) $\to$ MAR $\to$ M $\to$ MDR $\to$ ACC

此外，每取完一条指令还须为取下一条指令做准备，形成下一条指令的地址，即 (PC) + 1 $\to$ PC

#### 1.2.5 计算机系统的多级层次结构

-  软件

   1. 高级语言 虚拟机器 M4 用编译程序翻译成汇编语言程序
   2. 汇编语言 虚拟机器 M3 用汇编程序翻译成机器语言程序
   3. 操作系统 虚拟机器 M2 用机器语言解释操作系统

   ***

-  硬件

   4. 机器语言 实际机器 M1 用微指令解释机器指令
   5. 微指令系统 微程序机器 M0 由硬件直接执行微指令

### 1.3 计算机的性能指标

#### 1.3.1 计算机的主要性能指标

-  机器字长

   指计算机进行一次整数运算**所能处理的二进制数据的位数**，通常与 CPU 的寄存器位数、加法器有关，因此，机器字长一般等于内部寄存器的大小

   ::: tip 机器字长、指令字长、存储字长的区别和联系

   -  机器字长： 计算机能直接处理的二进制数据位数
   -  指令字长： 一个**指令字**中包含的二进制代码的位数
   -  存储字长： 一个**存储单元**存储的二进制代码的长度

   :::

-  数据通路带宽

   指数据总线一次所能并行传送信息的位数

-  主存容量

   主存所能存储信息的最大容量，可用字数 $\times$ 字长表示

-  运算速度
   -  吞吐量和响应时间
      -  吞吐量 指系统在单位时间内处理请求的数量
      -  响应时间 指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间
   -  主频和 CPU 时钟周期
      -  CPU 时钟周期 主频的倒数
      -  主频（CPU 时钟频率）
   -  CPI 执行一条指令所需时钟周期数
   -  MIPS、MFLOPS、GFLOPS、TFLOPS
      -  MIPS 每秒可以执行多少百万条指令
      -  MFLOPS 每秒执行多少百万次浮点运算
      -  GFLOPS 每秒执行多少十亿次浮点运算
      -  TFLOPS 每秒执行多少万亿次浮点运算

#### 1.3.2 几个专业术语

-  透明性 指站在某类用户的角度，感觉不到某个事物或属性的存在，即“看”不到
-  兼容 指计算机软件或硬件的通用性
-  固件 指将程序固定在 ROM 中组成的部件

### 1.4 计算机的发展与应用 <Badge text="~" type="tip"/>

#### 1.4.1 计算机的应用

-  科学计算和数据处理
-  工业控制和实时控制
-  网络技术
   -  电子商务
   -  网络教育
   -  敏捷制造
-  虚拟现实
-  办公自动化和管理信息系统
-  CAD / CAM / CIMS
-  多媒体技术
-  人工智能

#### 1.4.2 计算机的展望

-  计算机具有类似人脑的一些超级智能功能

   要求计算机的速度要足够快

-  芯片集成度的提高受一下三方面的限制
   -  芯片集成度受物理极限的制约
   -  按几何级数递增的制作成本
   -  芯片的功耗、散热、线延迟
-  替代传统的硅芯片

   -  光计算机

      利用光子取代电子进行运算和存储

   -  DNA 生物计算机

      通过控制 DNA 分子间的生化反应

   -  量子计算机

      利用原子所具有的量子特性

## 2 数据的表示和运算

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换

我们常用的计数方法为十进制，但它也只是一种对数字的表示方法而已，在计算机中更常用的是二进制，为了增加可读性，同时引入了十六进制和八进制

很明显，二进制与十六进制、二进制与八进制都是可以非常轻易的相互转换的，任何进制与十进制相互转换也是很容易的，故不赘述

::: tip

计算机整数是连续表示的，但是小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示，例如 0.3，但是任何一个二进制小数都可以用十进制小数表示

:::

#### 2.1.2 真值和机器数

-  真值是我们想要表示的真实的数值

-  机器数是在计算机中表示真值的方法，比如原码、补码、反码和移码

#### 2.1.3 BCD 码

使用二进制来编码十进制数，通常使用 4 位二进制数来表示一位十进制数，很明显会有 6 种冗余状态

常用的 BCD 码如下

-  8421 码，有权码，各位权重分别为 8421
-  余 3 码，无权码，在 8421 码的基础上加 $(0011)_2$
-  2421 码，有权码，各位权重分别为 2421，特点是大于等于 5 的四位二进制树中最高位为 1

#### 2.1.4 字符与字符串

与数字一样，字符在计算机中也是需要经过编码后才能表示的

-  字符编码 ASCII 码

   使用 7 位二进制编码表示 128 个字符

   ::: tip 为什么 0~9 对应 ASCII 码 48~57？

   因为 48 二进制形式为 0110000 ，去掉高三位即 0，其他数字亦然

   :::

-  汉字的表示和编码

   使用更多字节以表示其他文字等字符

-  字符串的存放

   也即连续的一串字符，但是需要区分大端模式和小端模式

   ::: tip 什么是大端模式和小端模式

   大端存储与小端存储的区别只在于字内存储顺序不同，字间存储顺序是相同的

   -  大端存储字内的高位字节存储在这个字区域的低地址处（在前），是正常的逻辑顺序
   -  小端存储字内的高位字节存储在这个字区域的高地址处

   :::

#### 2.1.5 校验码

数据校验码的码距：任何两个合法码字之间最少变化的二进制位数

对于码距不小于 2 的数据校验码，开始具有检错能力，且码距越大，检错、纠错能力越强，检错能力总是大于等于纠错能力

-  奇偶校验码

   加上一个二进制位后，使得**整个校验码**中 1 的个数为奇（偶）数个，只能检奇数个错误，不能纠错

-  海明（汉明）校验码

   使用一个简单的例子来讲解汉明码的编码方式：

   **在 n = 4，k = 3 时，求 1010 的汉明码**

   -  首先==确定校验位的分布==（$2^{i-1}$ 位），本例中即为 1、2、4 位，故海明码各位分别为 $D_4, D_3, D_2, P_3, D_1, P_2, P_1$
   -  然后==分组形成校验关系==，比如 $D_1$ 放在第 3 位，则由 $P_1$（第一位）与 $P_2$（第二位）共同校验，$D_4$ 由 $P_1$（第一位）、$P_2$（第二位）与 $P_3$（第四位）共同校验，其余同理
   -  ==确定校验位取值==，取值为由该校验位所校验的各位求异或，比如 $P_1$ 校验了 $D_1$、$D_2$ 与 $D_4$ ，故 $P_1 = D_1 \oplus D_2 \oplus D_4$
   -  利用校验位进行==校验==，对每个校验组求异或，比如 $S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4$ ，依次求出 $S_3S_2S_1$ ，如果结果为 000 ，则无错，否则有错，且该值为错误的位号，比如 $S_3S_2S_1 = 110$ ，则可知第六位出错

-  循环冗余校验（CRC）码

   在 K 位信息码后拼接 R 位校验码，R 位校验码是利用发送端与接收端共同约定的生成多项式得到的

   同样是使用一个简单的例子来说明：

   **设生成多项式为 $G(x) = x^3 + x^2 + 1$ ，信息码为 101001，求对应的 CRC 码**

   -  首先将原信息码左移 R 位，低位补 0，得到 101001000
   -  然后对移位后的信息码，用生成多项式进行模 2 出发，产生余数

      ::: tip 什么是模 2 除法与模 2 减法

      既不进位也不借位的运算，故模 2 减法与模 2 加法的结果相同，都是逐位异或运算，模 2 除法类似于算数除法，减法时使用的是模 2 减法

      :::

   -  将余数拼接在左移后的编码后，这里将 001 拼接在 101001 后，即 101001001
   -  检错和纠错，接收端对接收到的 CRC 码用生成多项式做模 2 除法，若余数为 0 ，则无错，否则余数即指示错误的位

---

新旧分界线

---

## 3 系统总线

### 3.1 总线的基本概念

#### 3.1.1 为什么要用总线

避免分散连接使得 CPU 难以设计
如果是分散连接，CPU 要做好多好多引脚，而且每增加一种设备 CPU 就要加一些引脚，可扩展性就很差啦

#### 3.1.2 总线(BUS)是什么

1. 总线是连接各个部件的信息传输线，是各个部件共享的传输介质
2. 总线十分繁忙，同一时刻只能有一对设备使用总线，因此总线容易成为瓶颈，但是其结构简单、可扩展性好，故使用该总线
   另外哈弗总线及其原理参见[PIC 哈弗总线](./PIC.md)
3. 一条总线的传输单元仍然是位，并行才能同时传输多位
4. 同时只能有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息

#### 3.1.3 总线上信息的传送

1. 串行
   `-------`
2. 并行 只适合短距离运输

```
------
------
------
------
```

而且现在串行速率比并行高，参考->[为什么目前的串行比并行传输快](https://www.cnblogs.com/juner/p/5514615.html)

#### 3.1.4 总线结构的计算机举例

1. 单总线结构框图 易成为瓶颈
2. 面向 CPU 的双总线结构框图
   1. I/O 总线
   2. M 总线
3. 以存储器为中心的双总线结构框图
   1. 存储总线
   2. 系统总线

### 3.2 总线的分类

1. 片内总线 芯片内部的总线
2. 系统总线 计算机各部件之间的信息传输线
   1. **_数据总线_** **双向** 与机器字长、存储字长有关
   2. **_地址总线_** **单向** 与存储地址、I/O 地址有关
   3. **_控制总线_** **有出 有入**
3. 通信总线
   用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信
   传输方式也分为串行通信总线与并行通信总线

### 3.3 总线特性及性能指标

#### 3.3.1 总线物理实现

BUS 印刷在主板上 各模块插在主板上

#### 3.3.2 总线特性

1. 机械特性 尺寸、形状、管脚数、排列顺序
2. 电气特性 传输方向和有效的电平范围
3. 功能特性 每根传输线的功能 可分为地址、数据、控制、状态反馈
4. 时间特性 信号的时序关系

#### 3.3.3 总线的性能指标

1. 总线宽度 数据线的根数
2. 标准传输率 每秒传输的最大字节数（MBps）
3. 时钟同步/异步 同步、不同步
4. 总线复用 地址线与数据线复用，可以减少芯片管脚数
5. 信号线数 地址线、数据线、和控制线的总和
6. 总线控制方式 突发、自动、仲裁、逻辑、计数
7. 其他指标 负载能力

#### 3.3.4 总线标准

### 3.4 总线结构

#### 3.4.1 单总线结构

#### 3.4.2 多总线结构

1. 双总线结构
2. 三总线结构

   1. 形式 1
      主存与**高速外设**间额外增加一条**DMA 总线**，使得高速外设得以直接与主存交换数据，而低速外设仍需要通过 I/O 总线并由 CPU 调度进而与主存交换数据 2. 形式 2
      主存与 CPU 之间增加一个**Cache**，Cache 与 CPU 由局部总线连接，由局部 I/O 控制器控制
      此外，一条扩展总线连接所有的外围设备，使得外设速度较慢

3. 四总线结构
   结合三总线形式 1 和 2 的优点，在形式 2 的 Cache 上扩展出一个高速总线，高速总线连接高速设备，另外高速总线扩展出一个扩展总线进而连接低速外设

#### 3.4.3 总线结构举例

1. 传统微型机总线结构
2. VL-BUS 局部总线结构
3. PCI 总线结构
4. 多层 PCI 总线结构

### 3.5 总线控制

#### 3.5.1 总线判优控制

1. 基本概念
   -  主设备 对总线有**控制权**
   -  从设备 **响应**从主设备发来的总线命令
   -  总线判优控制
   ```
               |-链式查询
    |---集中式< -计数器定时查询
   <           |-独立请求方式
    |---分布式
   ```
1. 链式查询
   **BS-总线忙 BR-总线请求 BG-总线同意**
   I/O 接口通过 BR 请求总线使用，BG 逐个向下查询，总线使用权交给遇到的第一个请求的接口，然后这个接口通过 BS 设置总线忙
   特点：优先级由连接方式事先确定，如果某设备优先级低，很可能他的请求一直得不到应答；而且对电路故障非常敏感；有个优点就是简单啦、增删设备很容易 blabla
1. 计数器定时查询
   I/O 接口通过 BR 请求总线使用，计数器循环累加从设备地址线向下查询，直到遇到第一个请求的接口，将总线使用权交由它，然后这个接口通过 BS 设置总线忙
   特点：优先级设置很灵活；需要$[log_2n]$条设备地址线
1. 独立请求方式
   每个接口都与控制机构有连接，控制机构有排队器

#### 3.5.2 总线通信控制

1. 目的
   解决通信双方**协调配合**问题
2. 总线传输周期
   1. 申请分配阶段 **主模块申请**，总线仲裁决定
   2. 寻址阶段 主模块向从模块**给出地址**和**命令**
   3. 传数阶段 主模块和从模块**交换数据**
   4. 结束阶段 主模块**撤销有关信息**
3. 总线通信的四种方式
   1. 同步通信 由**统一时标**控制数据传送 _需要一个时钟_
   2. 异步通信 采用**应答方式**，没有公共时钟标准 _不互锁、半互锁、全互锁_ 要求各模块速度匹配，不然受限于最低速的模块，因此也导致了长度不能过长
   3. 半同步通信 **同步、异步结合** 在同步基础上增加 WAIT 信号，若其位于低电平则等待一个时钟周期后再次检测
   4. 分离式通信 充分**挖掘**系统**总线每个瞬间**的潜力
      1. 主模块申请占用总线，使用完后即放弃总线的使用权
      2. ~~从模块准备数据~~，解决从模块准备数据仍占用总线的问题
      3. 从模块申请占用总线（或者说这时它已经是主模块了），将各种信息送至总线上
      4. 特点：各模块有权申请占用总线；同步通信；准备数据不占用宗霞；总线被占用时无空闲

## 4 存储器

### 4.1 概述

#### 4.1.1 存储器分类

1. 按存储介质分类
   1. 半导体存储器 TTL、MOS $\to$ 易失
   2. 磁表面存储器 磁头、载磁体
   3. 磁芯存储器 硬磁材料、环状元件 $\to$ 非易失
   4. 光盘存储器 激光、磁光材料
      > 本质上只有 3 种：半导体、磁、光
2. 按存取方式分类
   1. 存取时间与物理地址无关（随机访问）
      -  随机存储器（RAM） 在程序的执行过程中可读可写
      -  只读存储器（ROM） 在程序的执行过程中只读
   2. 存取时间与物理地址有关（串行访问）
      -  顺序存取存储器 磁带
      -  直接存取存储器 磁盘
3. 按在计算机中的作用分类
   ![Principles_of_computer_composition01](../Images/Principles_of_computer_composition01.png)
   **Flash Memory**是半导体存储器，速度介于主存与磁盘之间，可做 U 盘、硬盘（SSD）和辅存缓冲
   **Cache**材料便是静态 RAM，速度比主存快

#### 4.1.2 存储器的层次结构

![Principles_of_computer_composition02](../Images/Principles_of_computer_composition02.png)
![Principles_of_computer_composition03](../Images/Principles_of_computer_composition03.png)

### 4.2 主存储器

#### 4.2.1 概述

1. 主存的基本组成
2. 主存和 CPU 的联系
3. 主存中存储单元地址的分配
   ![Principles_of_computer_composition04](../Images/Principles_of_computer_composition04.png)
   > 字长为 16 位时，每 W 为 16 位，即 2 字节，故共 8MW
4. 主存的技术指标
   1. 存储容量 主存存放二进制代码的总位数
   2. 存储速度
      -  存取时间 存储器的**访问时间** （读出时间 写入时间）
      -  存取周期 **连续**两次**独立**的存储器操作所需的**最小间隔时间** （读周期 写周期）
   3. 存储器的带宽 位/秒

#### 4.2.2 半导体芯片简介

1. 半导体存储芯片的基本结构
   ![Principles_of_computer_composition05](../Images/Principles_of_computer_composition05.png)
   ![Principles_of_computer_composition06](../Images/Principles_of_computer_composition06.png)
   片选线的作用：
   Example：
   用`16K x 1位`的存储芯片组成`64K x 8位`的存储器
   1. 首先需要用 8 个这样的芯片组成`16K x 8位`的芯片组，当需要读写某个地址的数据时，对每个芯片中该地址数据（1 位）进行读写，就相当于同时读写 8 位。 2. 再将 4 组这样的芯片组组在一起，对每组进行编址，比如第一组便是 0\~16K-1，第二组是 16K\~32K-1，依次类推，便获得了拥有 64K 地址空间的存储芯片
2. 半导体存储芯片的译码驱动方式
   1. 线选法
      需要很庞大的地址线数
   2. 重合法
      采用二维矩阵，大大降低了译码的线，芯片的集成度就可以较高

#### 4.2.3 随机存取存储器（RAM）

1. 静态 RAM（SRAM）
   1. 静态 RAM 基本电路
      $T_1$\~$T_4$**触发器**，$T_5$、$T_6$行开关，$T_7$、$T_8$列开关 1. 静态 RAM 基本电路的读操作 2. 静态 RAM 基本电路的写操作 左右分别写原值与非值
   2. 静态 RAM 芯片举例
      ![Principles_of_computer_composition07](../Images/Principles_of_computer_composition07.png)
      -  Inter 2114 外特性分析：
         有 10 条地址线，4 条 I/O 线（数据线），因此存储容量为 1K x 4 位，使用重合法进行译码需要考虑如何同时读取 4 位数据
      -  Inter 2114 RAM 矩阵（64 x 64）
         行地址译码器 6 条，列地址译码器 4 条，此外根据列分为 4 组，如果读写某地址数据，只需要将每组中对应该地址的位进行读写
2. 动态 RAM（DRAM）
   1. 动态 RAM 基本电路
      **电容**电容！维持时间很短（2ms），所以需要定时刷新复原。
   2. 动态 RAM 芯片举例
      ![Principles_of_computer_composition08](../Images/Principles_of_computer_composition08.png)
      ![Principles_of_computer_composition09](../Images/Principles_of_computer_composition09.png)
      这里的读放大器是一个跷跷板电路，会将高低电平互相转换
   3. 动态 RAM 刷新
      电容中的电会在一段时间后漏掉，刷新只与**行地址**有关，每次刷新刷新一行数据，而不是某一存储单元数据 1. **集中刷新（存取周期为 0.5μs）**
      存在死区，那段时间 CPU 是无法读写数据的 2. **分散刷新（存取周期为 1μs）**
      不存在死区，但由于过度刷新，效率降低 3. **分散刷新与集中刷新相结合（异步刷新）**
      每 15.6μs 刷新一行，2ms 刚好刷新 128 行，如果将刷新安排在指令译码阶段，不会出现死区
3. 动态 RAM 和静态 RAM 的比较

| &nbsp;   | DRAM | SRAM   |
| -------- | ---- | ------ |
| 存储原理 | 电容 | 触发器 |
| 集成度   | 高   | 低     |
| 芯片引脚 | 少   | 多     |
| 功耗     | 小   | 大     |
| 价格     | 低   | 高     |
| 速度     | 低   | 高     |
| 刷新     | 有   | 无     |
| 主要用途 | 主存 | 缓存   |

#### 4.2.4 只读存储器（ROM）

1. 掩模 ROM（MROM）
   -  行列选择线交叉处有 MOS 管为“1”
   -  行列选择线交叉处无 MOS 管为“0”
2. PROM（一次性编程）
   -  熔丝断为“0”
   -  熔丝未断为“1”
3. EPROM（多次性编程）
   N 型沟道浮动栅 MOS 电路 紫外线全部擦洗
   -  D 端加正电压 形成浮动栅 S 与 D 不导通为“0”
   -  D 端不加正电压 不形成浮动栅 S 与 D 导通为“1”
4. EEPROM（多次性编程）
   -  电可擦写
   -  局部擦写
   -  全部擦写
5. Flash Memory(闪速型存储器)

| &nbsp; | &nbsp;                                             |
| ------ | -------------------------------------------------- |
| EPROM  | 价格便宜 集成度高                                  |
| EEPROM | 电可擦写重写，比 EPROM 快，且具备了 RAM 的一些功能 |

#### 4.2.5 存储器与 CPU 的连接

1. 存储器容量的扩展 1. 位扩展（增加存储字长）
   比如用 2 片`1K X 4位`存储芯片组成`1K X 8位`的存储器，需求是 10 根地址线、8 根数据线，材料是 10 根地址线、4 根数据线，所以就需要将两个芯片地址线直接接入，而数据线则是各占一半，以达到对某一地址数据同时进行读写 2. 字扩展（增加存储字的数量）
   比如用 2 片`1K X 8位`存储芯片组成`2K X 8位`的存储器，需求是 11 根地址线、8 根数据线，材料是 10 根地址线、8 根数据线，数据线直接接入就好，而多出来的地址线可作为片选择线（CS），便可对两个存储芯片地址进行衔接 3. 字、位扩展
   比如用 8 片`1K X 4位`存储芯片组成`4K X 8位`的存储器，先考虑位扩展，每组用 2 个存储芯片组成`1K X 8位`的存储器，然后再考虑字扩展，利用片选译码将额外两根地址线分配到四组存储器中
   ![Principles_of_computer_composition10](../Images/Principles_of_computer_composition10.png)
2. 存储器与 CPU 的连接
   1. 地址线的连接
   2. 数据线的连接
   3. 读/写命令线的连接
   4. 片选线的连接
   5. 合理选择存储芯片
   6. 其他 时序、负载
   -  例 4.1 好难 QAQ
   -  例 4.2 这个还好 ٩(๑>◡<๑)۶

#### 4.2.7 提高访存速度的措施

解决 CPU 速度与存储体访问速度不匹配问题

-  采用高速器件
-  采用层次结构 Cache - 主存
-  调整主存结构
   1. 单体多字系统 增加存储字长，但这样使得存储字作为整体，产生了很多麻烦
   2. 多体并行系统
      -  高位交叉 适合提供存储体容量，并不适合提高存储体带宽，但也给并行存储提供了基础
      -  低位交叉 各个体轮流编址，适合提高存储体带宽，多存储体轮流存取，解决了 CPU 与存储器速度差异的问题
   3. 高性能存储芯片
      -  SDRAM(同步 DRAM)
         在系统时钟的控制下进行读出和写入
      -  RDRAM
      -  带 Cache 的 DRAM
         有利于*猝发式读取*

### 4.3 高速缓冲存储器

#### 4.3.1 概述

1. 问题的提出
   避免 CPU 出现“空等”现象
   利用**程序访问的局部性原理**： 1. **时间局部性**：是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。 2. **空间局部性**：是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。
2. Cache 的工作原理
   1. 主存和缓存的编址：
      主存和缓存按块存储，块的大小相同
   2. 命中与未命中
   3. Cache 的命中率：与 Cache 的容量与块长有关
   4. Cache-主存系统的效率（时间比）
3. Cache 的基本结构
   ![Principles_of_computer_composition13](../Images/Principles_of_computer_composition13.png)
4. Cache 的*读写*操作
   1. 读
      命中则访问 Cache；未命中则访问主存，若 Cache 未满则将新的主存块调入 Cache，若满则执行替换算法并调入
   2. 写
      1. 写直达法
         Cache 与主存一直同步，实现简单但容易频繁对某个内存写入
      2. 写回法
         Cache 在替换时才写回，虽然解决了上面的频繁写的问题，但复杂且使得多核（每个核心带 Cache）Cache 不同步等问题
5. Cache 的改进
   1. 增加 Cache 的级数
      片内 Cache
      片外 Cache
      ![Principles_of_computer_composition14](../Images/Principles_of_computer_composition14.png)
   2. 统一缓存和分立缓存 -> 指令 Cache 与数据 Cache 分立

#### 4.3.2 Cache - 主存的地址映射

| 方法       | 特点                                                     | 优缺点             |
| ---------- | -------------------------------------------------------- | ------------------ |
| 直接映射   | 某一主存块**只能固定**映射到**某一**缓存块               | 不灵活、速度快     |
| 全相联映射 | 某一主存块**能**映射到**任一**缓存块                     | 利用率高、速度慢   |
| 组相联映射 | 某一主存块**只能**映射到**某一**缓存**组**中的**任一块** | 两者折中，使用较多 |

#### 4.3.3 替换算法

1. 先进先出（FIFO）算法 并没有提现程序的局部性原理
2. 近期最少使用（LRU）算法

### 4.4 辅助存储器

#### 4.4.1 概述

1. 特点 不直接与 CPU 交换信息
2. 磁表面存储器的技术指标
   1. 记录密度 道密度 位密度
   2. 存储容量
   3. 平均寻址时间 寻道时间 + 等待时间
      辅存的速度 = 寻址时间 + 磁头读写时间
   4. 数据传输率
   5. 误码率 出错信息位数与读出信息的总位数比值

#### 4.4.2 磁记录原理和记录方式

1. 磁记录原理

#### 4.4.3 硬磁盘存储器

1. 硬磁盘存储器的类型
   1. 固定磁头和移动磁头
   2. 可换盘和固定盘
2. 硬磁盘存储器结构
   主机 磁盘控制器 磁盘驱动器 盘片
   1. 磁盘驱动器 2. 磁盘控制器
      -  接收主机发来的命令，转换成磁盘驱动器的控制命令
      -  实现主机和驱动器之间的数据格式转换 \* 控制磁盘驱动器读写
         是主机与磁盘驱动器之间的接口 3. 盘片 由硬质铝合金材料制成

#### 4.4.4 软磁盘存储器

1. 概述

|      | 硬盘                     | 软盘     |
| ---- | ------------------------ | -------- |
| 速度 | 高                       | 低       |
| 磁头 | 固定、活动               | 活动     |
|      | 浮动                     | 接触盘片 |
| 盘片 | 固定盘、盘组大部分不可换 | 可换盘片 |
| 价格 | 高                       | 低       |
| 环境 | 苛刻                     |

2. 软盘片
   由聚酯薄膜制成，不过反正没人用啦已经……

#### 4.4.5 光盘存储器

1. 概述
   采用光存储技术 利用激光写入和读出 1. 第一代光存储技术 采用非磁性介质 不可采写 2. 第二代光存储技术 采用磁性介质 可擦写
2. 光盘的存储原理
   只读型和只写一次型 热作用（物理或化学变化）
   可擦写光盘 热磁效应

## 5 输入输出系统

### 5.1 概述

#### 5.1.1 输入输出系统的发展概况

1. 早期
   分散连接
   CPU 和 I/O 设备穿行工作 程序查询方式
2. 接口模块和 DMA 阶段
   总线连接
   CPU 和 I/O 设备并行工作 （中断方式 DMA 方式 ）
3. 具有通道结构的阶段
4. 具有 I/O 处理机的阶段

#### 5.1.2 输入输出系统的组成

1. I/O 软件
   1. I/O 指令 CPU 指令的一部分
      操作码 命令码 设备码
   2. 通道指令 通道自身的指令
      指出数组的首地址、传送字数、操作命令
2. I/O 硬件
   设备 I/O 接口
   设备 设备控制器 通道

#### 5.1.3 I/O 设备与主机的联系方式

1. I/O 设备编址方式
   1. 统一编址 用取数、存数指令（要求地址线足够，比如 64 位系统寻址范围足够大，完全可以使用统一编址）
   2. 不统一编址 有专门的 I/O 指令
2. 设备选址
   用设备选择电路识别是否被选中
3. 传送方式
   1. 串行
   2. 并行
4. 联络方式
   1. 立即响应
   2. 异步工作采用应答信号
      1. 并行
      2. 串行
   3. 同步工作采用同步时标
5. I/O 设备与主机的连接方式
   1. 辐射式连接 每套设备都配有一套控制线路和一组信号线，不便与增删设备
   2. 总线连接 便于增删设备

#### 5.1.4 I/O 设备与主机信息传送的控制方式

1. 程序查询方式 CPU 和 I/O 串行工作，踏步等待
2. 程序中断方式 CPU 和 I/O 部分地并行工作，但是会有保存现场和恢复现场的复杂操作
3. DMA 方式 CPU 和 I/O 并行工作，该时间 CPU 可以执行非访存的指令（指令早就取在指令缓存器啦）

**I/O 系统的自治能力越来越强**

### 5.2 外部设备

#### 5.2.1 概述

主机 I/O 接口 外设（设备控制器 机电磁光部分）
外设大致分三类

1. 人机交互设备 键盘、鼠标、打印机、显示器
2. 计算机信息存储设备 磁盘、光盘、磁带
3. 机-机通信设备 调制解调器等

#### 5.2.2 输入设备

1. 键盘
2. 鼠标
3. 触摸屏

#### 5.2.3 输出设备

1. 显示器
2. 打印机

#### 5.2.4 其他

#### 5.2.5 多媒体技术

### 5.3 I/O 接口

#### 5.3.1 概述

1. 实现设备的选择
2. 实现数据缓冲达到速度匹配
3. 实现数据串-并格式转换
4. 实现电平转换
5. 传送控制命令
6. 反映设备的状态（“忙”、“就绪”、“中断请求”）

#### 5.3.2 接口的功能和组成

1. 总线连接方式的 I/O 接口电路
   1. 设备选择线
   2. 数据线
   3. 命令线
   4. 状态线
2. 接口的功能和组成

| 功能               | 组成                                                                                               |
| ------------------ | -------------------------------------------------------------------------------------------------- |
| 选址功能           | 设备选择电路                                                                                       |
| 传送命令的功能     | 命令寄存器、命令译码器                                                                             |
| 传送数据的功能     | 数据缓冲寄存器                                                                                     |
| 反映设备状态的功能 | 设备状态标记</br>1.完成触发器 D</br>2.工作触发器 B</br>3.中断请求触发器 INTR</br>4.屏蔽触发器 MASK |

3. I/O 接口的基本组成
   ![Principles_of_computer_composition15](../Images/Principles_of_computer_composition15.png)

#### 5.3.3 接口类型

1. 按数据**传送方式**分类
   1. 并行接口
   2. 串行接口
2. 按功能**选择的灵活性**分类
   1. 可编程接口
   2. 不可编程接口
3. 按**通用性**分类
   1. 通用接口
   2. 专用接口
4. 按数据传送的**控制方式**分类
   1. 中断接口
   2. DMA 接口

### 5.4 程序查询方式

#### 5.4.1 程序查询方式的流程

1. 查询流程
2. 程序流程

#### 5.4.2 程序查询方式的接口电路

### 5.5 程序中断方式

#### 5.5.1 中断概念

外设发出中断指令后 CPU 转而执行中断服务程序

#### 5.5.2 I/O 中断的产生

CPU 与 I/O 设备部分并行工作

#### 5.5.3 程序中断方式的接口电路

1. 配置中断请求触发器和中断屏蔽触发器
   INTR=1 有请求 MASK=1 被屏蔽
2. 排队器 自左向右优先级降序排列（只有一个 1，其余全 0）
3. 中断向量地址形成部件
4. 程序中断方式接口电路的基本组成
   ![Principles_of_computer_composition16](../Images/Principles_of_computer_composition16.png)

#### 5.5.4 I/O 中断处理过程

1. CPU 响应中断的条件和时间
   1. 条件
      1. 允许中断触发器 ENIT=1
      2. 用开中断指令将 EINT 置“1”
      3. 用关中断指令将 EINT 置“0”或硬件自动复位
   2. 时间
      当 D=1 且 MASK=0 时，在每条指令执行阶段的结束前，CPU 发中断查询信号（将 INTR 置“1”）
2. I/O 中断处理过程
   略略略ヾ(๑╹◡╹)ﾉ"

#### 5.5.5 中断服务程序流程

1. 中断服务程序的流程
   1. 保护现场
      1. 程序断点的保护 中断隐指令完成（硬件的一系列操作，并不是真正的指令）
      2. 寄存器内容的保护 进栈指令
   2. 中断服务
   3. 恢复现场
   4. 中断返回
2. 单重中断和多重中断 1. 单重中断 不允许中断现行的中断服务程序 2. 多重中断 允许级别更高的中断源中断现行的中断服务程序
   两者实现上的区别仅在于中断服务程序中开中断的位置，多重中断将开中断提前，使设备服务过程中可以被中断

3. 主程序和服务程序抢占 CPU 示意图
   略略略(\*/ω＼\*)
   宏观上 CPU 和 I/O 并行工作
   微观上 CPU 中断现行程序为 I/O 服务

### 5.6 DMA 方式

#### 5.6.1 DMA 方式的特点

1. DMA 和程序中断两种方式的数据通路
   ![Principles_of_computer_composition17](../Images/Principles_of_computer_composition17.png)
   中断方式需要 CPU 中的寄存器，DMA 一般连接高速设备
2. DMA 与驻村交换数据的三种方式
   1. 停止 CPU 访问主存
      控制简单但未充分发挥 CPU 对准的利用率
   2. 周期挪用（或周期窃取）
      CPU 与 DMA 同时访存时 DMA 优先级更高
   3. DMA 与 CPU 交替访问
      不需要申请建立和归还总线的使用权，简单是简单，但利用率也很低

#### 5.6.2 DMA 接口的功能和组成

1. DMA 接口功能
   1. 向 CPU 申请 DMA 传送
   2. 处理总线控制权的转交
   3. 管理系统总线、控制数据传送
   4. 确定数据传送的首地址和长度
      修正传送过程中的数据地址和长度
   5. DMA 传送结束时，给出操作完成信号
2. DMA 接口组成
   略略略(￣ ▽ ￣)／

#### 5.6.3 DMA 的工作过程

1. DMA 传送过程
   1. 预处理
      1. 通知 DMA 控制逻辑传送方向
      2. 设备地址（DAR）
      3. 主存地址（AR）
      4. 传送字数（WC）
   2. 数据传送
   3. 后处理
      1. 校验送入主存的数是否正确
      2. 是否继续用 DMA
      3. 测试传送过程是否正确，错则转诊断程序
      4. 由中断服务程序完成
2. DMA 接口与系统的连接方式
   1. 具有公共请求线的 DMA 请求
   2. 独立的 DMA 请求
      类似于[总线的判优控制](#351-总线判优控制)
3. DMA 方式与程序中断方式的比较

| &nbsp;       | 中断方式     | DMA 方式     |
| ------------ | ------------ | ------------ |
| 数据传送     | 程序         | 硬件         |
| 响应时间     | 指令执行结束 | 存取周期结束 |
| 处理异常情况 | 能           | 不能         |
| 中断请求     | 传送数据     | 后处理       |
| 优先级       | 低           | 高           |

#### 5.6.4 DMA 接口的类型

1. 选择型
   在物理上连接多个设备，在逻辑上只允许连接一个设备
2. 多路型
   在物理上连接多个设备，在逻辑上允许多个设备同时工作
   ![Principles_of_computer_composition18](../Images/Principles_of_computer_composition18.png)

## 6 计算机的运算方法

### 6.1 无符号数和有符号数

#### 6.1.1 无符号数

#### 6.1.2 有符号数

1. 原码
2. 反码
3. 补码
   > 都没啥可说的，大计基都学过，倒是补码的由来值得一提，就是转了一圈又回来嘛，还有一些结论比如：
   > 补码的补码是原码啦，**一个数的补码带上符号位取补码就变成其相反数的补码**啦
4. 移码 就是把补码的符号位取反，这样就把原来的数映射到正值上了，就可以直接比较大小了

### 6.2 数的定点表示和浮点表示

#### 6.2.1 定点表示

#### 6.2.2 浮点表示

1. 浮点数的表示形式
   将一个数表示为$S * r^j$形式
   就是以 2 为底的科学计数法啦，只不过这里要求尾数不大于 1，也就是一个纯小数啦，如果是标准化的话，小数的二分位（貌似应该这么叫的吧，人家十进制是叫十分位的……），也要是 1
   总的来说，就是*阶符、阶码; 数符、尾数*，用原码还是补码什么的看要求

2. 浮点数的表示范围
   随便算算就好
   ![Principles_of_computer_composition19](../Images/Principles_of_computer_composition19.png)

3. 浮点数的规格化形式
   喔，**基数越大**可表示的浮点数**范围越大**随之**精度降低**哦

4. 机器零
   ![Principles_of_computer_composition20](../Images/Principles_of_computer_composition20.png)
   一种是尾数为零，一种是下溢

#### 6.2.3 IEEE754 标准

尾数规格化表示后非“0”的有效最高位为“1”，故可略去啦，增加尾数，增大精度
![Principles_of_computer_composition21](../Images/Principles_of_computer_composition21.png)

### 6.3 定点运算

#### 6.3.1 移位运算

1. 左移绝对值扩大 右移绝对值缩小
2. 规则

|      | 码制             | 添补代码 |
| ---- | ---------------- | -------- |
| 正数 | 原码、补码、反码 | 0        |
| 负数 | 原码             | 0        |
|      | 补码             | 左移添 0 |
|      | 补码             | 右移添 1 |
|      | 反码             | 1        |

可以**根据不溢出时候左面右面都是啥进行判断**呀

3. 算数移位的硬件实现
   ![Principles_of_computer_composition22](../Images/Principles_of_computer_composition22.png)

4. 算数移位和逻辑移位的区别
   就是**逻辑移位带上符号位**，仅此而已

#### 6.3.2 加减法运算

原码进行加减法运算时要判断是加还是减，但使用补的想法后使得加减法运算只需要做补码的加法即可

1. 补码加减运算公式
   ![Principles_of_computer_composition23](../Images/Principles_of_computer_composition23.png)
2. 溢出判断
   1. 一位符号位判溢出
      正正或者负负可能溢出，溢出后符号改变，故可使用**最高有效位的进位 ⊕ 符号位的进位 = 1**判断溢出
   2. 两位符号位判溢出
      额外增加一位符号位，**如果结果的双符号位相同则未溢出，如果不同则溢出**，而且最高符号位代表其真正的符号
3. 补码加减法的硬件配置
   ![Principles_of_computer_composition24](../Images/Principles_of_computer_composition24.png)

#### 6.3.3 乘法运算

1. 原码乘法

   1. 原码一位乘的过程
      ![Principles_of_computer_composition25](../Images/Principles_of_computer_composition25.png)

      > 已经使用过的乘数最低位会在逻辑右移中被丢弃，高位补 0，这样之前运算得到的溢出得到的“符号位”便参与运算了
      > 另外需要一个计数器记录移位次数，以判断乘数是否全部计算过，另外记得最后要把乘数的最高位也移走才是最终答案

   2. 原码一位乘硬件配置
      ![Principles_of_computer_composition26](../Images/Principles_of_computer_composition26.png)
      > 根据 Q 中的乘数最后一位判断是否加和，如果是 0 则控制门不从 X 传送被乘数到加法器，所以计数器是根据移位次数判断而不是加法次数判断

2. 补码乘法
   1. 补码一位乘运算规则
   2. Booth 算法
   3. Booth 算法的硬件配置

#### 6.3.4 除法运算

1. 原码除法
   ![Principles_of_computer_composition27](../Images/Principles_of_computer_composition27.png)

   1. 恢复余数法
      ![Principles_of_computer_composition28](../Images/Principles_of_computer_composition28.png)

      > 要记得减（加补码）之后如果是负数还要加回去，将余数恢复

      2. 不恢复余数法（加减交替法）
         ![Principles_of_computer_composition29](../Images/Principles_of_computer_composition29.png)
         ![Principles_of_computer_composition30](../Images/Principles_of_computer_composition30.png)

         > 不需要恢复余数了，要根据减之后的结果决定加还是减

      3. 原码加减交替除法硬件配置
         ![Principles_of_computer_composition31](../Images/Principles_of_computer_composition31.png)
         > 根据结果正负控制加还是减就好啦

### 6.4 浮点四则运算

#### 6.4.1 浮点加减运算

1. 对阶 使用补码求阶差，小阶向大阶看齐
2. 尾数求和
3. 规格化
   1. 规格化的定义 [1/2, 1)
   2. 规格化的判断 利用补码符号位和第一数位不同的性质（1 和 1/2 会是特例，1 是规格化、1/2 非规格化）
   3. 左规 尾数左移，阶码减一
   4. 右规 尾数溢出时（01.xxx/10.xxx），尾数右移，阶码加一
4. 舍入
   1. 0 舍 1 入法
   2. 恒置“1”法
5. 溢出判断

### 6.5 算数逻辑单元

#### 6.5.1 ALU 电路

#### 6.5.2 快速进位链

1. 并行加法器
2. 串行进位链
3. 并行进位链
   1. 单重分组跳跃进位链
   2. 双重分组跳跃进位链

## 7 指令系统

软硬件的交界面，软件调用指令集中的指令，让 CPU 执行这些指令

### 7.1 机器指令

#### 7.1.1 指令的一般格式

操作码字段 + 地址码字段

1. 操作码 —— 反映机器做什么操作
   1. 长度固定 用于指令字长较长的情况
   2. 长度可变 操作码分散在指令字的不同字段中
   3. 扩展操作码技术 操作码的位数随地址数的减少而增加，举个例子：
      -  4 位操作码，从 0000-1110，预留一位 1111 是干嘛的呢？看下面
      -  8 位操作码，从 1111 0000-1111 1110，咦又是预留一位，继续看下面
      -  12 位操作码，从 1111 1111 0000-1111 1111 1110，好了，现在基本上都明白了
      -  16 位操作码，从 1111 1111 1111 0000-1111 1111 1111 1111，哦这时候已经木有地址码了
         > 我们再看，4 位操作码时候可以有 1 条指令，8:15,12:15,16:16，诶？这个 1111 作为扩展标志是固定的嘛？当然不是啦，我们也可以定 1111 和 1110 作为扩展标记，那么 4 位就是 14 条指令，8 位就是<32 位地址码（取决于怎么对 12 位进行扩展）啦
2. 地址码
   1. 四地址（第一操作数地址，第二操作数地址，结果的地址，下一条指令地址）
      -  假设指令字长 32 位，操作码固定 8 位
      -  4 次访存
      -  寻址范围 64
   2. 三地址（第一操作数地址，第二操作数地址，结果的地址，下一条指令地址放在 PC）
      -  4 次访存
      -  寻址范围 256
   3. 二地址（第一操作数地址（结果的地址），第二操作数地址，下一条指令地址放在 PC）
      -  4 次访存
      -  寻址范围 4K
   4. 二地址（第一操作数地址，第二操作数地址，结果的地址放在 ACC，下一条指令地址放在 PC）
      -  3 次访存
      -  寻址范围 4K
   5. 一地址（第一操作数地址，第二操作数（结果）的地址放在 ACC，下一条指令放在 PC）
      -  2 次访存
      -  寻址范围 16M
   6. 零地址（无地址码，比如对 ACC 内数据操作或者对栈内元素操作）

#### 7.1.2 指令字长

-  指令字长决定于
   1. 操作码的长度
   2. 操作数地址的长度
   3. 操作数地址的个数

1. 如果指令字长固定 —— 指令字长=存储字长
2. 如果指令字长可变 —— 按字节的倍数变化

#### 7.1.3 小结

1. 当用一些硬件资源代替指令字中的地址码字段后
   -  可扩大指令的寻址范围
   -  可缩短指令字长
   -  可减少访存次数
2. 当指令的地址字段为寄存器时
   -  可缩短指令字长
   -  指令执行阶段不访存

### 7.2 操作数类型和操作种类

#### 7.2.1 操作数类型

1. 地址 无符号整数
2. 数字 定点数、浮点数、十进制数
3. 字符 ASCII
4. 逻辑数 逻辑运算

#### 7.2.2 数据在存储器中的存放方式

-  一方面是字地址是高字节地址或者是低字节地址
-  另一方面……（首先，存储字长 64 位，机器字长 32）
   1. 从任意位置开始存储
      -  读写控制复杂
      -  不浪费存储资源
   2. 从一个存储字的起始位置开始访问
      -  读写控制简单
      -  浪费存储资源
   3. 边界对齐方式 —— 从地址的整数倍位置开始访问
      ![Principles_of_computer_composition32](../Images/Principles_of_computer_composition32.png)
      > 比如说一个字节的数据，那么就可以放在任意位置，如果是半字（2 字节）那么必须存偶数地址，以此类推，双字必须存在 8 的整数倍地址

#### 7.2.3 操作类型

1. 数据传送

| 源   | 寄存器 | 寄存器                  | 存储器                | 存储器 |
| ---- | ------ | ----------------------- | --------------------- | ------ |
| 目的 | 寄存器 | 存储器                  | 寄存器                | 存储器 |
| 例   | MOVE   | STORE</br>MOVE</br>PUSH | LOAD</br>MOVE</br>POP | MOVE   |

2. 算数逻辑操作
   加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算、与、或、非、异或、位操作、位测试、位清除、位求反
   如 8086：ADD SUB MUL DIV INC DEC CMP NEG AAA AAS AAM AAD AND OR NOT XOR TEST
3. 移位操作
   -  算数移位
   -  逻辑移位
   -  循环移位（带进位和不带进位）
4. 转移
   1. 无条件转移 JMP
   2. 条件转移
      -  结果为零转 JZ
      -  结果溢出转 JO
      -  结果有进位转 JC
      -  跳过一条指令 SKP
         例：`SKP DZ; D=0 则跳`
   3. 调用和返回 (CALL RETURN)
   4. 陷阱（Trap）与陷阱指令 —— 意外事故的中断
      -  一般不提供给用户直接使用
         在出现事故时，由 CPU 自动产生并执行（隐指令）
      -  设置供用户使用的陷阱指令
         如 8086 `INT TYPE; 软中断`
5. 输入和输出
   如果输入和输出直接编址在内存单元，那么不必有额外的 IO 指令

### 7.3 寻址方式

确定本条指令的**操作数地址**或下一条要执行指令的**指令地址**

#### 7.3.1 指令寻址

1. 顺序 (PC) + 1 ---> PC（这里这个“1”是指指令长度，要考虑定长和非定长的情况）
2. 跳跃 由转移指令指出（比如 JMP）

#### 7.3.2 跳跃寻址

操作码 寻址特征 形式地址 A
**形式地址** 指令字中的地址
**有效地址** 操作数中的真实地址，需要形式地址与寻址特征经过一定的运算得出
约定： 指令字长 = 存储字长 = 机器字长

1. 立即寻址
   `OP # A`
   形式地址 A 就是**操作数**
   -  指令执行阶段不访存
   -  A 的位数限制了立即数的范围
2. 直接寻址
   EA = A 有效地址由形式地址直接给出
   -  执行阶段访问一次存储器
   -  A 的位数决定了该指令操作数的寻址范围 \* 操作数的地址不易修改（必须修改 A）
3. 隐含寻址
   操作数地址隐含在操作码中（某个操作数隐含在某个寄存器中，比如 ADD 指令一个操作数隐含在 ACC 中） \* 指令字中少了一个地址字段，可缩短指令字长
4. 间接地址
   EA = (A) 有效地址由形式地址间接提供
   -  执行指令阶段 2 次访存
   -  可扩大寻址范围 \* 便于编制程序
5. 寄存器寻址
   $EA = R_i$ 有效地址即为寄存器编号
   -  执行阶段不访存，只访问寄存器，执行速度快
   -  寄存器个数有限，可缩短指令字长
6. 寄存器间接寻址
   $EA=(R_i)$ 有效地址在寄存器中
   -  有效地址在寄存器中，操作数在存储器中，执行阶段访存
   -  便于编制循环程序
7. 基址寻址
   1. 采用专用寄存器作基址寄存器
      EA = (BR) + A BR 为基址寄存器
      -  可扩大寻址范围
      -  可利于多道程序
      -  BR 内容由操作系统或管理程序确定
      -  在程序的执行过程中 BR 内容不变，形式地址 A 可变
   2. 采用通用寄存器作基址寄存器
      -  由用户指定哪个通用寄存器作为基址寄存器
      -  基址寄存器的内容由操作系统确定
      -  在程序的执行过程中$R_0$内容不变，形式地址 A 可变
8. 变址寻址
   EA = (IX) + A IX 为变址寄存器（专用），通用寄存器也可以作为变址寄存器
   -  可扩大寻址范围
   -  IX 的内容由用户给定
   -  在程序的执行过程中 IX 内容可变，形式地址 A 不可变
   -  便于处理数组问题
9. 相对寻址
   EA = (PC) + A
   A 是相对于当前指令的位移量（可正可负，补码）
   -  A 的位数决定操作数的寻址范围
   -  程序浮动
   -  广泛用于转移指令
   -  执行指令之前 PC 就加‘一’了喔
10.   堆栈寻址
      1. 堆栈的特点
         -  -  硬堆栈 多个寄存器
            -  软堆栈 指定的存储空间
         -  先进后出 栈顶地址由 SP 指出
            -  进栈 (SP) - 1 ---> SP
            -  出栈 (SP) + 1 ---> SP
      2. 堆栈寻址举例
      3. SP 的修改与主存编址方法有关
         1. 按字编址
         2. 按字节编址
            -  存储字长 16 位
            -  存储字长 32 位

### 7.4 指令格式举例

#### 7.4.1 设计指令格式时应考虑的各种因素

1. 指令系统的兼容性
2. 其他因素
   -  操作类型 包括指令个数及操作的难易程度
   -  数据类型 确定哪些数据可参与操作
   -  指令格式 指令字长是否固定 操作码位数、是否采用扩展操作码技术 地址码尾数、地址个数、寻址方式类型
   -  寻址方式 指令寻址、操作数寻址
   -  寄存器个数 寄存器的多少直接影响指令的执行时间

### 7.5 RISC 技术

精简指令计算机

#### 7.5.1 RISC 的产生和发展

> 典型程序中程序 80%的语句仅仅使用处理机中 20%的指令

> 执行频度高的简单指令，因复杂指令的存在，执行速度无法提高

-----> 用 20%的简单指令组合不常用的 80%的指令功能

#### 7.5.2 RISC 的主要特征

-  选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合
-  指令长度固定、指令格式种类少、寻址方式少
-  只有 LOAD/STORE 指令访存
-  CPU 中有多个通用寄存器
-  采用流水技术 一个时钟周期内完成一条指令
-  采用组合逻辑实现控制器

#### 7.5.3 CISC 的主要特征

-  系统指令复杂庞大，各种指令使用频度相差大
-  指令长度不固定、指令格式种类多、寻址方式多
-  访存指令不受限制
-  大多数指令需要多个时钟周期执行完毕
-  采用微程序控制器

#### 7.5.4 RISC 和 CISC 的比较

1. RISC 更能充分利用 VLSI 芯片的面积
2. RISC 更能提高计算机运算速度
3. RISC 便于设计，可降低成本，提高可靠性
4. RISC 不易实现指令系统兼容

## 8 CPU 的结构和功能

### 8.1 CPU 的结构

#### 8.1.1 CPU 的功能

1. 控制器的功能
   -  取指令
   -  分析指令
   -  执行指令，发出各种操作命令
   -  控制程序输入及结果的输出
   -  总线管理
   -  处理异常情况和特殊请求
      > 指令控制 操作控制 时间控制 处理中断 数据加工
2. 运算器的功能
   -  实现算术运算和逻辑运算

#### 8.1.2 CPU 结构框图

1. CPU 与系统总线
   -  控制总线 双向
   -  数据总线 双向
   -  地址总线 单向

| bla      | bla         |
| -------- | ----------- |
| 指令控制 | PC IR       |
| 操作控制 | CU 时序电路 |
| 时间控制 | 同上        |
| 数据加工 | ALU 寄存器  |
| 处理中断 | 中断系统    |

即 ==ALU、寄存器、中断系统、CU==

#### 8.1.3 CPU 的寄存器

1. 用户可见寄存器
   1. 通用寄存器 存放操作数，可作某种寻址方式所需的专用寄存器
   2. 数据寄存器 存放操作数（满足各种数据类型），两个寄存器拼接存放双倍字长数据
   3. 地址寄存器
      存放地址，其位数应满足最大的地址范围用于特殊的寻址方式 段基值 栈指针
   4. 条件码寄存器
      存放条件吗，可作程序分支的依据，如正、负、零、溢出、进位等
2. 控制和状态寄存器
   1. 控制寄存器
      PC -> MAR -> M -> MDR -> IR
      控制 CPU 操作
      其中 MAR、MDR、IR 用户不可见，PC 用户可见
   2. 状态寄存器
      状态寄存器 存放条件码
      PSW 寄存器 存放程序状态字（保存调用子程序前的断点和现场）

#### 8.1.4 控制单元 CU 和中断系统

1. CU 产生全部**指令**的微操作命令**序列**
   -  组合逻辑设计 硬连线逻辑（速度比较快）
   -  微程序设计 存储逻辑
2. 中断系统

#### 8.1.5 ALU

参见第六章

### 8.2 指令周期

#### 8.2.1 指令周期的基本概念

1. 指令周期
   取出并执行一条指令所需的全部时间
   完成一条指令（取指周期 执行周期）
2. 每条指令的指令周期不同
3. 具有间接寻址的指令周期
4. 具有中断周期的指令周期
5. 指令后期流程
   取指周期 （间址周期） 执行周期 （中断周期）
6. CPU 工作周期的标志
   **CPU**访存有四种性质
   -  取指令 取指周期
   -  取地址 间址周期
   -  存取操作数或结果 执行周期
   -  存程序断点 中断周期

#### 8.2.2 指令周期的数据流

图中红色箭头为第一步
![Principles_of_computer_composition33](../Images/Principles_of_computer_composition33.png)

### 8.3 指令流水

#### 8.3.1 如何提高机器速度

1. 提高访存速度
   -  高速芯片 Cache
   -  多体并行
2. 提高 I/O 和主机之间的传送速度
   -  中断
   -  DMA
   -  通道
   -  I/O 处理机
   -  多总线
3. 提高运算器速度
   -  高速芯片
   -  改进算法
   -  快速进位链

-  提高整机处理能力
   -  高速器件
   -  改进系统结构，开发系统的并行性

#### 8.3.2 系统的并行性

1. 并行的概念
   -  并发 两个或两个以上事件在**同一时间段**发生
   -  同时 两个或两个以上事件在**同一时刻**发生（时间上互相重叠）
2. 并行性的等级
   -  过程级（程序、进程） 粗粒度 软件实现
   -  指令级（指令之间、指令内部） 细粒度 硬件实现

#### 8.3.3 指令流水的原理

1. 指令的串行执行
   总有一个部件空闲
2. 指令的二级流水
   取指和执行阶段时间上**完全重叠**
   指令周期**减半**，速度提高**一倍**
3. 影响指令流水效率加倍的因素
   1. 执行时间 > 取指时间
      取指令部件 -> 指令部件缓冲区 -> 执行指令部件
   2. **条件转移指**令对指令流水的影响
      必须等上调指令执行结束，才能确定下条指令的地址，造成时间损失
      解决：猜测法等
4. 指令的内存流水
   -  FI 取指令
   -  DI 指令译码
   -  CO 形成操作数的地址
   -  FO 取操作数
   -  EI 执行
   -  WO 结果的写回

#### 8.3.4 影响指令流水线性能的因素

1. 结构相关 不同指令争用同意功能部件产生资源冲突
   解决方法：
   -  停顿
   -  指令存储器和数据存储器分开（哈弗结构） \* 指令预取技术（适用于访存周期短的情况）
2. 数据相关
   不同指令因重叠操作，可能改变操作数

   -  写后读相关（RAW）
   -  读后写相关（WAR） \* 写后写相关（WAW）

      解决办法：

      -  后推法
      -  改用旁路技术

3. 控制相关
   由**转移指令**引起

#### 8.3.5 流水线性能

1. 吞吐率
   单位时间内流水线所完成指令或输出结果的数量，设 m 段的流水线各段时间为 $\Delta t$
   -  最大吞吐率
      $T_{pmax}=\frac{1}{\Delta t}$
   -  实际吞吐率
      连续处理 n 条指令的吞吐率为
      $T_p=\frac{n}{m\cdot\Delta} t+(n-1)\dot\Delta t$
2. 加速比$S_p$
   m 段的流水线的速度与等功能的非流水线的速度之比
   设 m 段的流水线各段时间为$\Delta t$
   完成 n 条指令在等效的非流水线上共需$T=n\cdot\Delta t+(n-1)\cdot\Delta t$
   完成 n 条指令在等效的非流水线上共需$T^{'}=nm\cdot\Delta t$
   则$S_p=\frac{nm\cdot\Delta t}{m\cdot\Delta t+(n-1)\cdot\Delta t}=\frac{nm}{m+n-1}$
3. 效率
   流水线中各功能段的利用率
   由于流水线有建立时间和排空时间
   因此各功能段的设备不可能一直处于工作状态

#### 8.3.6 流水线的多发技术

1. 超标量技术
   -  每个时钟周期内可并发多条独立指令，配置多个功能部件
   -  不能调整指令的执行顺序，通过**编译优化**技术，把可并行执行的指令搭配起来
2. 超流水线技术
   -  在**一个时钟周期**内再分段，在一个时钟周期内一个功能部件使用多次
   -  不能调整指令的执行顺序，考编译程序解决优化问题
3. 超长指令字技术
   -  由编译程序挖掘出指令间潜在的并行性，**将多条能并行操作的指令组合成一条**，具有多个操作码字段的超长指令字（可达几百位）
   -  采用多个处理部件

#### 8.3.7 流水线结构

1. 指令流水结构
   -  取指令部件
   -  指令译码部件
   -  地址形成部件
   -  取操作数部件
   -  操作执行部件
   -  回写结果部件
      > 要锁存
2. 运算流水线
   完成浮点加减运算可分**对阶、尾数求和、规格化**三段
   -  对阶功能部件
   -  尾数加部件 \* 规格化部件

> 分段原则 每段操作时间尽量一致

### 8.4 中断系统

#### 8.4.1 概述

1. 引起中断的各种因素
   1. 人为设置的中断 如*转管指令*
   2. 程序性事故 溢出、操作码不能识别、除法非法
   3. 硬件故障
   4. I/O 设备
   5. 外部事件 用*键盘中断*现行程序
2. 中断系统需解决的问题
   1. 各中断源*如何*向 CPU*提出请求*
   2. 各中断源*同时*提出*请求*怎么办
   3. CPU 什么*条件*、什么*时间*、以什么*方式响应中断*
   4. 如何*保护现场*
   5. 如何*寻找入口地址*
   6. 如何*恢复现场*，如何*返回*
   7. 处理终端的过程中又*出现新的中断*怎么办
      > 硬件 + 软件

#### 8.4.2 中断请求标记和中断判优逻辑

1. 中断请求标记 INTR

   -  一个请求源 一个*INTR*中断请求标记触发器
   -  多个 INTR 组成中断请求标记寄存器
      > INTR 分散在各个中断源的接口电路中
      > OR
      > INTR 集中在 CPU 的中断系统内

2. 中断判优逻辑
   1. 硬件实现（排队器）
      1. 分散在各个中断源的接口电路中 -> 链式排队器
      2. 集中在 CPU 内 -> 逻辑电路
   2. 软件实现（程序查询）

#### 8.4.3 中断服务程序入口地址的寻找

1. 硬件向量法
   -  速度快，但灵活性不高
2. 软件查询法
   -  SKP
   -  JMP

#### 8.4.4 中断响应

1. 响应中断的条件
   允许中断触发器 EINT=1
2. 响应中断的时间
   指令执行周期结束时刻由 CPU 发查询信号
3. 中断隐指令
   1. 保护程序断点
      断点存于特定地址（0 号地址）内 / 断点进栈
   2. 寻找服务程序入口地址
   -  向量地址 -> PC（硬件向量法）
   -  中断识别程序 入口地址 M -> PC（软件查询法）
   3. 硬件关中断

#### 8.4.5 保护现场和恢复现场

1. 保护现场
   -  断点 **中断隐指令**完成
   -  寄存器内容 **中断服务程序**完成
2. 恢复现场 **中断服务程序**完成

中断服务程序

-  保护现场 PUSH
-  其他服务程序 视不同请求源而定
-  恢复现场 POP
-  中断返回 IRET

#### 8.4.5 多重中断

1. 多重中断的概念
   在执行中断服务程序的过程中，出现了更重要 的，需要及时处理的新事件
2. 实现多重中断的条件
   1. 提前设置开中断指令
   2. 优先级别高的中断源有权中断优先级别低的中断源
3. 屏蔽技术

   1. 屏蔽触发器的作用
      -  $MASK_i$=0，未屏蔽
      -  $MASK_i$=1，屏蔽
   2. 屏蔽字
      ![Principles_of_computer_composition34](../Images/Principles_of_computer_composition34.png)
   3. 屏蔽技术可改变处理优先等级

   -  响应优先级 不可改变
   -  处理优先级 可改变（通过重新设置屏蔽字，不用上面那个图里那么无聊的设置）
      > 执行谁的中断服务程序就启用谁的中断服务字啦，主程序的中断服务字为全 0

   4. 中断屏蔽技术的其他应用
      可以人为地屏蔽某个中断源的请求
   5. 新屏蔽字的设置
      -  保护现场
      -  **置屏蔽字**
      -  开中断
      -  中断服务
      -  **关中断**
      -  恢复现场
      -  **恢复屏蔽字**
      -  **开中断**
      -  中断返回

4. 多重中断的断点保护

   1. 断点进栈 中断隐指令完成
   2. 断点存入“0”地址 中断隐指令完成
      中断周期

      -  0 -> MAR
      -  命令存储器写
      -  PC -> MDR 断点 -> MDR
      -  (MDR) -> 存入存储器 > 三次中断，三个断点都存入“0”地址，如何保证断点不丢失？

   3. 程序断点存入“0”地址的断点保护
      ![Principles_of_computer_composition35](../Images/Principles_of_computer_composition35.png)

## 9 控制单元的功能

### 9.1 微操作命令的分析

完成一条指令分四个工作周期

-  取指周期
-  间址周期
-  执行周期
-  中断周期

#### 9.1.1 取指周期

-  PC -> MAR -> 地址总线
-  1 -> R
-  M(MAR) -> MDR
-  MDR -> IR
-  OP(IR) -> CU
-  (PC) + 1 -> PC

#### 9.1.2 间址周期

-  指令形式地址 -> MAR
-  Ad(IR) -> MAR
-  1 -> R
-  M(MAR) -> MDR
-  MDR -> Ad(IR)

#### 9.1.3 执行周期

1. 非访存指令
   1. CLA 清 A 0 -> ACC
   2. COM 取反 $\overline{ACC}$ -> ACC
   3. SHR 算术右移 L(ACC) -> R(ACC), $ACC_0$ -> $ACC_0$
   4. CSL 循环左移 R(ACC) -> L(ACC), $ACC_0$ -> $ACC_n$
   5. STP 停机指令 0 -> G
2. 访存指令
   1. 加法指令 ADD X
   2. 存数指令 STA X
   3. 取数指令 LDA X
3. 转移指令
   1. 无条件转 JMP X
      Ad(IR) -> PC
   2. 条件转移 BAN X（负则转）
      $A_0\cdot Ad(IR)+\bar{A}_0(PC) -> PC$
4. 三类指令的指令周期
   1. 非访存 取指、执行
   2. 直接访存 取指、执行
   3. 间接访存 取指、间址、执行
   4. 转移 取指、执行
   5. 间接转移 取指、间址、执行

#### 9.1.4 中断周期

1. ==**保存断点**==
2. ==**形成中断服务程序入口地址**==
3. ==**关中断**==

### 9.2 控制单元的功能

#### 9.2.1 控制单元的外特性

1. 输入信号
   1. **时钟**
      CU 受**时钟控制**，一个时钟脉冲发一个操作命令或一组需同时执行的操作命令
   2. **指令寄存器**
      OP(IR) -> CU，**控制信号与操作码有关**
   3. **标志**
      CU**受标志控制**
   4. **外来信号**
      如 INTR 中断请求、HRQ 总线请求
2. 输出信号
   1. CPU 内的各种控制信号
   2. 送至控制总线的信号

#### 9.2.2 控制信号举例

1. 不采用 CPU 内部总线的方式
2. 采用 CPU 内部总线方式

#### 9.2.3 多级时序系统

1. 机器周期
   1. 机器周期的概念
      -  所有指令执行过程中的一个基准时间
   2. 确定机器周期需考虑的因素
      1. 每条指令的执行步骤
      2. 每一步骤所需的时间
   3. 基准时间的确定
      1. 以完成**最复杂指令**功能的时间为准
      2. 以**访问一次存储器**的时间为基准
         > 若指令字长=存储字长，那么取指周期=机器周期
2. 时钟周期（节拍、状态）
   -  一个机器周期内可以完成若干个微操作
   -  每个微操作需一定的时间
   -  将一个机器周期分成若干个时间相等的时间段（节拍、状态、时钟周期）
   -  **时钟周期是控制计算机操作的最小单位时间**
   -  **用时钟周期控制产生一个或几个微操作命令**

![Principles_of_computer_composition36](../Images/Principles_of_computer_composition36.png)

3. 多级时序系统
   机器周期、节拍（状态）组成多级时序系统
   -  一个**指令周期**包含若干个**机器周期**
   -  一个**机器周期**包含若干个**时钟周期**
4. 机器速度与机器主频的关系
   -  机器的**主频 f 越快**机器的**速度也越快**
   -  在机器周期所含时钟周期数相同的前提下，两机**平均指令执行速度之比**等于**两机主频之比**
   -  机器速度不仅与主频有关，还与机器周期中所含时钟周期（主频的倒数）数以及指令周期中所含的**机器周期数**有关

#### 9.2.4 控制方式

产生不同微操作命令序列所有的时序控制方式

1. 同步控制方式
   -  任一微操作均有统一基准时标的时序信号控制
   1. 采用定长的机器周期
      -  以最长的微操作序列和最复杂的微操作作为标准
      -  机器周期内节拍数相同
   2. 采用不定长的机器周期
      -  机器周期内节拍数不等
   3. 采用中央控制和局部控制相结合的方法
2. 异步控制方式
   -  无基准时标信号
   -  无固定的周期节拍和严格地时钟同步
   -  采用**应答**方式
3. 联合控制方式
   -  同步与异步相结合
4. 人工控制方式
   1. Reset
   2. 连续和单条指令
   3. 符合停机开关

## 10 控制单元的设计

### 10.1 组合逻辑设计

#### 10.1.1 组合逻辑控制单元框图

1. CU 外特性
   CU、节拍发生器、操作码译码、标志
2. 节拍信号

#### 10.1.2 微操作的节拍安排

采用同步控制方式
一个机器周期内有 3 个节拍（时钟周期）（需要多少个节拍是需要具体分析的）
CPU 内部结构采用非总线方式

1. 安排微操作时序的原则
   1. 原则一 微操作的先后顺序不得随意更改
   2. 原则二 被控对象不同的微操作，尽量安排在一个节拍内完成
   3. 原则三 占用时间较短的微操作，尽量安排在一个节拍内完成，并允许有先后顺序
2. 取指周期微操作的节拍安排
   例：
   ![Principles_of_computer_composition37](../Images/Principles_of_computer_composition37.png)
3. 间址周期微操作的节拍安排
4. 执行周期微操作的节拍安排
5. 中断周期微操作的节拍安排

#### 10.1.3 组合逻辑设计步骤

1. 列出操作时间表
   ![Principles_of_computer_composition38](../Images/Principles_of_computer_composition38.png)
2. 写出微操作命令的最简表达式
   ![Principles_of_computer_composition39](../Images/Principles_of_computer_composition39.png)
3. 画出逻辑图

### 10.2 微程序设计

#### 10.2.1 微程序设计思想的产生

![Principles_of_computer_composition40](../Images/Principles_of_computer_composition40.png)

#### 10.2.2 微程序控制单元框图及工作原理

1. 机器指令对应的微程序
   ![Principles_of_computer_composition41](../Images/Principles_of_computer_composition41.png)
2. 微指令控制单元的基本框图
3. 工作原理
   ![Principles_of_computer_composition42](../Images/Principles_of_computer_composition42.png)
   > 可以看出，对于微指令来说执行过程是很简单的，微指令只需要形成对微操作命令的索引，而微操作命令是存储在控制存储器中的

#### 10.2.3 微指令的编码方式（控制方式）

1. 直接编码（直接控制）方式

   -  伪指令的操作控制字段中
   -  **每一位代表一个微操作指令** \* 某位为“1”表示该控制信号有效

   > 不需要译码，速度最快

2. 字段直接编码方式（显式编码）

   -  将微指令的控制字段分为若干“段”
   -  **每段经译码后发出控制信号** \* 每个字段中的命令是互斥的

   > 缩短了微指令字长，增加了译码时间

3. 字段间接编码方式（隐式编码）
   各字段译码结果不仅与本字段输入相关，还和其他字段译码结果相关

4. 混合编码
   直接编码和字段编码（直接和间接）混合使用

5. 其他

#### 10.2.4 微指令序列地址的形成

1. 微指令的下地址字段指出
2. 根据机器指令的操作码形成
3. 增量计数器
   (CMAR) + 1 -> CMAR
4. 分支转移
   操作控制字段 | 转移方式 | 转移地址
   转移方式 知名判别条件
   转移地址 指明转移成功后的去向
5. 通过测试网络
   图略
6. 由硬件产生微程序入口地址
   第一条微指令地址 由专门硬件产生
   中断周期 由硬件产生中断周期微程序首地址
7. 后续微指令形成方式原理图
   ![Principles_of_computer_composition43](../Images/Principles_of_computer_composition43.png)

#### 10.2.5 微指令格式

1. 水平型微指令
   -  一次定义并执行多个并行操作
   -  如：直接编码、字段直接编码、字段间接编码、直接和字段混合编码
2. 垂直型微指令
   -  类似机器指令操作码的方式
   -  由微操作码字段规定微指令的功能
3. 两种微指令格式的比较
   1. 水平型微指令比垂直型微指令**并行操作能力强，灵活性强**
   2. 水平型微指令执行一条机器指令所要的微指令**数目少、速度快**
   3. 水平型微指令**用较短的微程序结构喊去较长的微指令结构**
   4. 水平型微指令与机器指令**差别大**

#### 10.2.6 静态微程序设计和动态微程序设计

-  静态 微程序无需改变，采用 ROM
-  动态 通过改变微指令和微程序改变机器指令，有利于仿真，采用 EPROM

#### 10.2.7 毫微程序设计

1. 毫微程序设计的基本概念
   -  **微程序设计**用**微程序解释机器指令**
   -  **毫微程序设计**用**毫微程序解释微指令**
   -  **毫微程序与微指令**的关系好不**微指令与机器指令**的关系
2. 毫微程序控制存储器的基本组成
   ![Principles_of_computer_composition44](../Images/Principles_of_computer_composition44.png)
   毫微程序是使用垂直型微指令

#### 10.2.8 串行微程序控制和并行微程序控制

微指令层面对**取指**和**执行**的串行和并行（流水）

#### 10.2.9 微程序设计举例

略，有点长

# Reference

1. 2020 年计算机组成原理考研复习指导 - 王道
2. 《Computer Organization and Design (The Hardware/Software Interface)》 David A. Patterson, John L. Hennessy
3. 《计算机科学导论》 佛罗赞、莫沙拉夫
4. 计算机组成原理（[上](https://www.icourse163.org/course/HIT-309001) & [下](https://www.icourse163.org/course/HIT-1001527001)） - 哈尔滨工业大学 - 中国大学 MOOC
5. 丁男老师课程
