---
title: Principles of Computer Composition
date: 2019-11-17
categories:
   - 经纶·注
tags:
   - CS
   - kaoyan
---

::: warning ♻️ Reviewing

《计算机组成原理》复习笔记

:::

<!-- more -->

## 1 计算机系统概述

### 1.1 计算机发展历程

#### 1.1.1 计算机硬件的发展

-  计算机的四代变化

   -  第一代计算机 电子管时代
   -  第二代计算机 晶体管时代
   -  第三代计算机 中小规模集成电路时代
   -  第四代计算机 超大规模集成电路时代

-  计算机元件的更新换代

   -  摩尔定律 当价格不变时，集成电路上可容纳的晶体管数目，约每隔 18 个月便会增加一倍，性能也将提升一倍
   -  半导体存储期的发展 单芯片 1KB 到现在的 GB 级
   -  微处理器的发展 8 位到现在的 64 位（机器字长）

#### 1.1.2 计算机软件的发展

-  机器语言 面向机器
-  汇编语言 面向机器
-  高级语言 面向问题
   -  FORTRAN 科学计算和工程计算
   -  PASCAL 结构化程序设计
   -  C++ 面向对象
   -  Java 适应网络环境

### 1.2 计算机系统层次结构

#### 1.2.1 计算机系统的组成

通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率，而用软件实现可以提高灵活性，但效率往往不如硬件实现高

#### 1.2.2 计算机硬件的基本组成

计算机硬件系统由**运算器**、**存储器**、**控制器**、**输入设备**和**输出设备** 5 大部件组成

-  早期的冯·诺依曼计算机

   ![PCC01.png{copyright:Wangdao}](../Images/PCC01.png)

   -  特点

      -  计算机由**五大部件**组成
      -  指令和数据以**同等地位**存于存储器，可按地址寻访
      -  指令和数据用二进制表示
      -  指令由**操作码**和**地址码**组成
      -  指令在存储器内**按顺序存放**
      -  以运算器为中心

-  现代计算机的组织结构

   以存储器为中心，使 I/O 操作尽可能地绕过 CPU ，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率

   ![PCC02.png{copyright:Wangdao}](../Images/PCC02.png)

-  计算机的功能部件

   -  输入设备 将信息转换成机器能识别的形式
   -  输出设备 将结果转换成人们熟悉的形式
   -  存储器 用来存放程序和数据

      -  主存储器

         -  存储体 存放二进制信息
         -  地址寄存器 MAR 存放访存地址，经过地址译码后找到所选的存储单元

            由于其用于寻址，所以其位数对应着存储单元的个数，与 PC 位数相等

         -  数据寄存器 MDR 主存和其他部件的中介机构，用于暂存要从存储器读或写的信息

            MDR 的位数和存储字长相等，一般为字节的二次幂倍

      -  辅助存储器

   -  运算器 完成算术运算和逻辑运算

      -  算数逻辑单元 ALU
      -  若干通用寄存器
         -  累加器 ACC
         -  乘商寄存器 MQ
         -  操作数寄存器 X
         -  变址寄存器 IX
         -  基址寄存器 BR
         -  程序状态寄存器 PSW

   -  控制器 指挥各部件自动协调地进行工作

      -  程序计数器 PC 用来存放当前欲执行指令的地址，可以自动加一以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路
      -  指令寄存器 IR 用来存放当前的指令，其内容来自主存的 MDR

   ![PCC03.png{copyright:Wangdao}](../Images/PCC03.png)

   主机包含 CPU 和主存，其他的硬件装置统称外设，主要为外存和 I/O 设备

   另外，现代计算机的 CPU 通常还集成了 Cache 、 MAR 、MDR ，而不是在主存里

#### 1.2.3 计算机软件的分类

-  系统软件
   -  操作系统（OS）
   -  数据库管理系统（DBMS）
   -  语言处理程序
   -  分布式软件系统
   -  ……
-  应用软件 按任务需要编制成的各种程序

#### 1.2.4 计算机的工作过程

1. 把程序和数据装入主存储器
2. 从程序的起始地址运行程序
3. 用程序的首地址从存储器中取出第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成这条指令功能，并计算下一条指令的地址
4. 用新得到的指令地址继续当初第二条指令并执行，直到程序结束为止；每条指令都是在**取指、译码和执行**的循环过程中完成的

以取数指令为例

-  ==取指==： PC $\to$ MAR $\to$ M $\to$ MDR $\to$ IR
-  ==分析==： OP(IR) $\to$ CU
-  ==执行==： Ad(IR) $\to$ MAR $\to$ M $\to$ MDR $\to$ ACC

此外，每取完一条指令还须为取下一条指令做准备，形成下一条指令的地址，即 (PC) + 1 $\to$ PC

#### 1.2.5 计算机系统的多级层次结构

-  软件

   1. 高级语言 虚拟机器 M4 用编译程序翻译成汇编语言程序
   2. 汇编语言 虚拟机器 M3 用汇编程序翻译成机器语言程序
   3. 操作系统 虚拟机器 M2 用机器语言解释操作系统

   ***

-  硬件

   4. 机器语言 实际机器 M1 用微指令解释机器指令
   5. 微指令系统 微程序机器 M0 由硬件直接执行微指令

### 1.3 计算机的性能指标

#### 1.3.1 计算机的主要性能指标

-  机器字长

   指计算机进行一次整数运算**所能处理的二进制数据的位数**，通常与 CPU 的寄存器位数、加法器有关，因此，机器字长一般等于内部寄存器的大小

   ::: tip 机器字长、指令字长、存储字长的区别和联系

   -  机器字长： 计算机能直接处理的二进制数据位数
   -  指令字长： 一个**指令字**中包含的二进制代码的位数
   -  存储字长： 一个**存储单元**存储的二进制代码的长度

   :::

-  数据通路带宽

   指数据总线一次所能并行传送信息的位数

-  主存容量

   主存所能存储信息的最大容量，可用字数 $\times$ 字长表示

-  运算速度
   -  吞吐量和响应时间
      -  吞吐量 指系统在单位时间内处理请求的数量
      -  响应时间 指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间
   -  主频和 CPU 时钟周期
      -  CPU 时钟周期 主频的倒数
      -  主频（CPU 时钟频率）
   -  CPI 执行一条指令所需时钟周期数
   -  MIPS、MFLOPS、GFLOPS、TFLOPS
      -  MIPS 每秒可以执行多少百万条指令
      -  MFLOPS 每秒执行多少百万次浮点运算
      -  GFLOPS 每秒执行多少十亿次浮点运算
      -  TFLOPS 每秒执行多少万亿次浮点运算

#### 1.3.2 几个专业术语

-  透明性 指站在某类用户的角度，感觉不到某个事物或属性的存在，即“看”不到
-  兼容 指计算机软件或硬件的通用性
-  固件 指将程序固定在 ROM 中组成的部件

### 1.4 计算机的发展与应用 <Badge text="~" type="tip"/>

#### 1.4.1 计算机的应用

-  科学计算和数据处理
-  工业控制和实时控制
-  网络技术
   -  电子商务
   -  网络教育
   -  敏捷制造
-  虚拟现实
-  办公自动化和管理信息系统
-  CAD / CAM / CIMS
-  多媒体技术
-  人工智能

#### 1.4.2 计算机的展望

-  计算机具有类似人脑的一些超级智能功能

   要求计算机的速度要足够快

-  芯片集成度的提高受一下三方面的限制
   -  芯片集成度受物理极限的制约
   -  按几何级数递增的制作成本
   -  芯片的功耗、散热、线延迟
-  替代传统的硅芯片

   -  光计算机

      利用光子取代电子进行运算和存储

   -  DNA 生物计算机

      通过控制 DNA 分子间的生化反应

   -  量子计算机

      利用原子所具有的量子特性

## 2 数据的表示和运算

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换

我们常用的计数方法为十进制，但它也只是一种对数字的表示方法而已，在计算机中更常用的是二进制，为了增加可读性，同时引入了十六进制和八进制

很明显，二进制与十六进制、二进制与八进制都是可以非常轻易的相互转换的，任何进制与十进制相互转换也是很容易的，故不赘述

::: tip

计算机整数是连续表示的，但是小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示，例如 0.3，但是任何一个二进制小数都可以用十进制小数表示

:::

#### 2.1.2 真值和机器数

-  真值是我们想要表示的真实的数值

-  机器数是在计算机中表示真值的方法，比如原码、补码、反码和移码

#### 2.1.3 BCD 码

使用二进制来编码十进制数，通常使用 4 位二进制数来表示一位十进制数，很明显会有 6 种冗余状态

常用的 BCD 码如下

-  8421 码，有权码，各位权重分别为 8421
-  余 3 码，无权码，在 8421 码的基础上加 $(0011)_2$
-  2421 码，有权码，各位权重分别为 2421，特点是大于等于 5 的四位二进制树中最高位为 1

#### 2.1.4 字符与字符串

与数字一样，字符在计算机中也是需要经过编码后才能表示的

-  字符编码 ASCII 码

   使用 7 位二进制编码表示 128 个字符

   ::: tip 为什么 0~9 对应 ASCII 码 48~57？

   因为 48 二进制形式为 0110000 ，去掉高三位即 0，其他数字亦然

   :::

-  汉字的表示和编码

   使用更多字节以表示其他文字等字符

-  字符串的存放

   也即连续的一串字符，但是需要区分大端模式和小端模式

   ::: tip 什么是大端模式和小端模式

   用一个例子来说明：大端和小端分别如何存储 `0x12345678`

   -  大端模式会将 `0x12` 存储在这个高字节存储在低位地址，所以该连续四字节应该分别为 `0x12` `0x34` `0x56` `0x78`，地址依次增高，这其实符合人们的阅读习惯
   -  小端模式正好相反，它会将 `0x12` 这个高字节存储在高位地址，也就是 `0x78` `0x56` `0x34` `0x12` ，虽然不满足人们的阅读习惯，但是它更具有解释性，如果将其看作连续的一个数据，它就是 `0x12345678`

   :::

#### 2.1.5 校验码

数据校验码的码距：任何两个合法码字之间最少变化的二进制位数

对于码距不小于 2 的数据校验码，开始具有检错能力，且码距越大，检错、纠错能力越强，检错能力总是大于等于纠错能力

-  奇偶校验码

   加上一个二进制位后，使得**整个校验码**中 1 的个数为奇（偶）数个，只能检奇数个错误，不能纠错

-  海明（汉明）校验码

   使用一个简单的例子来讲解汉明码的编码方式：

   **在 n = 4，k = 3 时，求 1010 的汉明码**

   -  首先 ==确定校验位的分布==（$2^{i-1}$ 位），本例中即为 1、2、4 位，故海明码各位分别为 $D_4, D_3, D_2, P_3, D_1, P_2, P_1$
   -  然后 ==分组形成校验关系==，比如 $D_1$ 放在第 3 位，则由 $P_1$（第一位）与 $P_2$（第二位）共同校验，$D_4$ 由 $P_1$（第一位）、$P_2$（第二位）与 $P_3$（第四位）共同校验，其余同理
   -  ==确定校验位取值==，取值为由该校验位所校验的各位求异或，比如 $P_1$ 校验了 $D_1$、$D_2$ 与 $D_4$ ，故 $P_1 = D_1 \oplus D_2 \oplus D_4$
   -  利用校验位进行 ==校验==，对每个校验组求异或，比如 $S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4$ ，依次求出 $S_3S_2S_1$ ，如果结果为 000 ，则无错，否则有错，且该值为错误的位号，比如 $S_3S_2S_1 = 110$ ，则可知第六位出错

-  循环冗余校验（CRC）码

   在 K 位信息码后拼接 R 位校验码，R 位校验码是利用发送端与接收端共同约定的生成多项式得到的

   同样是使用一个简单的例子来说明：

   **设生成多项式为 $G(x) = x^3 + x^2 + 1$ ，信息码为 101001，求对应的 CRC 码**

   -  首先将原信息码左移 R 位，低位补 0，得到 101001000
   -  然后对移位后的信息码，用生成多项式进行模 2 出发，产生余数

      ::: tip 什么是模 2 除法与模 2 减法

      既不进位也不借位的运算，故模 2 减法与模 2 加法的结果相同，都是逐位异或运算，模 2 除法类似于算数除法，减法时使用的是模 2 减法

      :::

      ![PCC04.png{copyright:Wangdao}](../Images/PCC04.png)

   -  将余数拼接在左移后的编码后，这里将 001 拼接在 101001 后，即 101001001
   -  检错和纠错，接收端对接收到的 CRC 码用生成多项式做模 2 除法，若余数为 0 ，则无错，否则余数即指示错误的位

### 2.2 定点数的表示与运算

#### 2.2.1 定点数的表示

-  无符号数和有符号数的表示

   -  无符号数
   -  有符号数 使用 0 代表正号， 1 代表负号

-  机器数的定点表示

   -  定点小数（纯小数） 小数点隐含在符号位之后、有效数值位之前
   -  定点整数（纯整数） 小数点隐含在有效数值为之后

-  原码、反码、补码、移码

   用 1bit 符号位 + 2bit 有效数值位的简单例子来说明

   > 第一行列出了当原码为 000、001……时对应的**真值**，其他行类似

   |      | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 |
   | ---- | --- | --- | --- | --- | --- | --- | --- | --- |
   | 原码 | 0   | 1   | 2   | 3   | -0  | -1  | -2  | -3  |
   | 反码 | 0   | 1   | 2   | 3   | -3  | -2  | -1  | -0  |
   | 补码 | 0   | 1   | 2   | 3   | -4  | -3  | -2  | -1  |
   | 移码 | -4  | -3  | -2  | -1  | 0   | 1   | 2   | 3   |

   ::: warning

   如未特殊说明，各种转换都不带符号位，保证符号位不变

   :::

   -  原码 很简单，就是直接将最高位作为符号位，正为 0，负为 1，数值部分即为绝对值，很明显，它有两个 0，正负两部分相互独立，只要越界就溢出了
   -  反码 正数不变，负数对原码的数值部分取反，但是这样好像还是没什么太大用处（也许对称看着能好看些），但是可作为运算补码的中介
   -  补码 正数仍然不变，负数是反码 +1（码是 +1，真值自然会每个都 -1），这样我们不仅解决了 0 有两个（浪费一个可表示的数字），还使得正数域与负数域拼接起来了，0 - 1 很自然的就等于 -1 ，并不会有溢出，同时也大大降低了加法运算的难度

   ::: tip 补码运算的技巧

   -  对补码进行补码运算可得原码
   -  对补码进行**带上符号位的补码运算**可得其相反数的补码

   :::

   -  移码 将负数域与正数域调换一下（加个偏移量即可），保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

#### 2.2.2 定点数的运算

-  溢出判断

   -  一位符号位判溢出

      正正或者负负可能溢出，溢出后符号改变，故可使用**最高有效位的进位 $\oplus$ 符号位的进位 = 1**判断溢出

   -  两位符号位判溢出

      额外增加一位符号位，**如果结果的双符号位相同则未溢出，如果不同则溢出**，而且最高符号位代表其真正的符号

-  定点数的移位运算

   -  算术移位

      针对有符号数，移位过程中**保持符号位不变**

      -  正数 移位后出现的空位均以 0 填补
      -  负数 移位后出现的空位填补方式如下

         | 码制 | 添补代码            |
         | ---- | ------------------- |
         | 原码 | 0                   |
         | 补码 | 左移添 0 / 右移添 1 |
         | 反码 | 1                   |

      ::: tip 为什么负数的填补代码都不一样？

      因为负数的 0 的表示方法不一样，但是我们很容易知道原码应当填 0、反码应当填 1，而补码稍微复杂一些，从一个例子讲起

      ```
      10011|100 （原码）
      11100|011 （反码）
      11100|100 （补码）
      ```

      我们能发现一个规律，补码从右向左一直到第一个 1 ，都是和原码相同的，而再左面的都是和反码相同的，所以，补码右侧（左移）填补应该与原码相同，填 0，相应的，左侧（右移）填补应该与补码相同，填 1

      :::

   -  逻辑移位

      针对无符号数，所以无论左移右移，直接填 0 就好了

   -  循环移位

      移出的数位又被移入数据中，而是否带进位则要看是否将进位标志加入循环位移，循环移位操作特别适合将数据的低字节部分与高字节部分互换

-  定点数的加减法运算

   -  原码定点数的加减法运算

      需要考虑加还是减，并判断正负号，就很麻烦

   -  补码定点数的加减法运算

      符号位也参与运算，加法即两个补码直接相加，减法即加上减数的负数的补码

-  定点数的乘法运算

   -  原码一位乘法

      符号位和数值部分分开求

      -  符号位 两个符号的异或
      -  数值部分

         -  已经使用过的乘数最低位会在逻辑右移中被丢弃，高位补 0，这样之前运算得到的溢出得到的“符号位”便参与运算了
         -  另外需要一个计数器记录移位次数，以判断乘数是否全部计算过，另外记得最后要把乘数的最高位也移走才是最终答案
         -  这里考虑到定点小数运算时可能出现绝对值大于 1 的情况（并未溢出），所以部分积和被乘数取双符号位

      ::: tip 例

      $x = -0.1101, y = 0.1011$

      ![PCC11.png{copyright:Wangdao}](../Images/PCC11.png)

      -  符号位由异或求得为 `1`
      -  数值部分为 `0.10001111`

      即结果为 `-0.10001111`

      :::

   -  补码一位乘法（Booth 算法）

      -  符号位参与运算，运算的数均以补码表示
      -  乘数末位增加附加位 $y_{n+1}$ ，且初值为 0
      -  根据 $(y_n, y_{n+1})$ 的取值来确定操作（如下表）

         | $y_n$ | $y_{n+1}$ | 操作                                   |
         | ----- | --------- | -------------------------------------- |
         | 0     | 0         | 部分积右移一位                         |
         | 0     | 1         | 部分积加 $[X]_{complement}$，右移一位  |
         | 1     | 0         | 部分积加 $[-X]_{complement}$，右移一位 |
         | 1     | 1         | 部分积右移一位                         |

      ::: tip 例

      $x = -0.1101, y = 0.1011$

      ![PCC12.png{copyright:Wangdao}](../Images/PCC12.png)

      即结果的补码为 `1.01110001`，真值为 `-0.10001111`

      :::

-  定点数的除法运算

   -  原码除法运算

      同原码乘法，需要将符号位与数值部分分开计算

      -  恢复余数法

         当余数为负时，都需要再加上除数将余数恢复为正值，这将大大增加除法时间，所以一般不用

      -  加减交替法

         -  余数为正数时，下一步就直接减就好了
         -  余数为负数时，商上 0，在下一步加除数（替换下一步的减，当前步无需额外操作）即可，不需要再额外增加恢复余数这一步了

         ::: tip 例

         $x = 0.1011, y = 1.0011$

         ![PCC13.png{copyright:Wangdao}](../Images/PCC13.png)

         -  符号位为 `0`
         -  数值部分为 `0.1101` 余 `0.0111`

         即结果为 $+0.1101$ 余 $0.0111 \times 2^{-4}$

         :::

   -  补码除法运算

      同样的，补码也是有恢复余数法和加减交替法，但是恢复余数法一般不用，所以略去，另外，补码除法和补码乘法一样，是不需要单独算符号位的

      -  恢复余数法（略）
      -  加减交替法

         -  若余数与除数同号，则代表上一次够减，商上 `1`，下一次做减法
         -  若余数与除数异号，则代表上一次不够减，商上 `0`，下一次做加法
         -  末位恒置 `1`

         ::: tip 例

         $x = 0.1000, y = -0.1011$

         ![PCC14.png{copyright:Wangdao}](../Images/PCC14.png)

         -  符号位为 `0`
         -  数值部分补码为 `1.0101` 余 `0.0111`

         即结果为 $-0.1011$ 余 $0.0111 \times 2^{-4}$

         :::

#### 2.2.3 强制类型转换

-  同等字长不同类型的变量转换（比如 `short` 与 `unsigned short`），将会保留存储时的位值（补码），按照新的类型重新解释

   ::: tip 例

   将 `short x = -4312` 强制转换为 `unsigned short y`

   | 变量 | 值    | 补码                  |
   | ---- | ----- | --------------------- |
   | x    | -4321 | `1110 1111 0001 1111` |
   | y    | 61215 | `1110 1111 0001 1111` |

   结果为 `y = 61215`

   :::

-  大字长变量向小字长变量转换时（比如 `int` 向 `short`），将会将大字长变量高字节部分直接截断

@[code transcludeWith=LONG_TO_SHORT](@/Codes/PCC/01_type_conversion.c)

-  小字长变量向大字长变量转换时（比如 `short` 向 `int`），不仅将低字节部分复制过去，而且要对符号位进行扩展补充，以保证数值是不变的

@[code transcludeWith=SHORT_TO_LONG](@/Codes/PCC/01_type_conversion.c)

### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

-  浮点数的表示格式

   $N = r^E \times M$

   就是以 2 为底的科学计数法啦，只不过这里要求尾数不大于 1，也就是一个纯小数啦，如果是标准化的话，小数点后第一位也要是 1（原码）

   总的来说，就是**阶符、阶码; 数符、尾数**，用原码还是补码什么的看要求

-  规格化浮点数

   -  规格化格式

      数值部分范围 $[\frac{1}{2}, 1)$，但是补码负数有点特殊，范围为 $[-1, -\frac{1}{2})$

      即原码小数点后第一位必为 `1`(`0.1xxx` 与 `1.1xxx` 均为规格化)，而补码符号位与尾数最高位相反（`0.1xxx` 与 `1.0xxx` 均为规格化）

      另外，**基数越大**可表示的浮点数**范围越大**随之**精度降低**哦

   -  规格化方法

      -  左规 即经过运算后不满足规格化，需尾数左移，阶码减一（可能进行多次）
      -  右规 尾数溢出时（可用双符号位判断 `01.xxx/10.xxx`），尾数右移，阶码加一

-  浮点数表示范围

   ![PCC15.png{copyright:Wangdao}](../Images/PCC15.png)

   -  上溢 需进行溢出处理
   -  下溢 当做机器零处理

-  IEEE 754 标准

   ![PCC16.png{copyright:Wangdao}](../Images/PCC16.png)

   -  数符 1 位
   -  阶码 移码表示
   -  尾数 原码表示，由于最高位必为 `1`，为了能够表示更多有效位，这个 `1` 将隐含

   | 类型       | 数符 | 阶码 | 尾数数值 | 总位数 |
   | ---------- | ---- | ---- | -------- | ------ |
   | 短浮点数   | 1    | 8    | 23       | 32     |
   | 长浮点数   | 1    | 11   | 52       | 64     |
   | 临时浮点数 | 1    | 15   | 64       | 80     |

-  定点、浮点表示的区别

   -  范围 浮点范围增加
   -  精度 由于浮点有着很多位表示阶码，所以精度降低
   -  数的运算 浮点运算要对阶码和尾数运算，最后还要规格化，比较复杂
   -  溢出问题 尾数溢出可以右规，阶码溢出才是真的溢出

#### 2.3.2 浮点数的加减运算

1. 对阶 使用不嘛求阶差，小阶向大阶看齐
2. 尾数求和 将对阶后的尾数按定点数加（减）规则运算
3. 规格化 左规或右规
4. 舍入
   -  `0` 舍 `1` 入法： 类似于十进制的四舍五入
   -  恒置 `1` 法
5. 溢出判断
   -  上溢 中断处理
   -  下溢 按机器零处理

#### 2.3.3 强制类型转换

$char \to int \to long \to double$ 范围和精度都从小到大，可以放心转换，不会有损失（溢出或者精度损失）

值得注意的是， $int \to float$ 虽然不会发生溢出，但是是可能进行舍入的，因为 $float$ 尾数部分（24bit）比 $int$ 数值（32bit）少，所以最后几位可能会发生舍入

@[code transcludeWith=INT_TO_FLOAT](@/Codes/PCC/01_type_conversion.c)

### 2.4 算数逻辑单元（ALU）

#### 2.4.1 串行加法器和并行加法器

-  一位全加器

   全加器（FA）

   -  输入
      -  加数 $A_i$
      -  加数 $B_i$
      -  低位进位 $C_{i-1}$
   -  输出
      -  本位 $S_i = A_i \oplus B_i \oplus C_{i-1}$
      -  进位 $C_i = A_i B_i + (A_i \oplus B_i) C_{i-1}$

-  串行加法器

   只有一个全加器，数据逐位送入加法器中进行运算，所以运算慢

-  并行加法器

   多个全加器组成，各位同时运算，但是仍有一个制约其速度的最大问题：虽然各位同时提供，但是进位必须在低位计算结束后才能得到

   -  串行进位链

      正如上面所述，高位仍然需要等待低位的进位，速度仍然受限

   -  并行进位链

      在高位的表达式中直接带入低位进位的结果，当然这样越高位表达式越复杂，对应的逻辑电路也就越复杂，但这确实解决了速度的问题

   -  分组并行进位方式

      为了防止电路过于复杂，并获得比较可以接受的速度，可以对全加器进行分组，在组内使用并行进位链，组间需要分情况

      -  单级先行进位方式

         组内使用并行进位链，组间使用串行进位链

      -  多级先行进位方式

         相似的，这次使用的是分级的思想，还是需要分组，组内并行进位链，组间也是并行进位链

#### 2.4.2 算数逻辑单元的功能和结构

ALU 核心是一个并行加法器，同时能执行“与或非”等逻辑运算

![PCC17.png{copyright:Wangdao}](../Images/PCC17.png)

-  输入
   -  $A_i$ $B_i$，输入变量
   -  $K_i$ 控制信号，用于控制做何种运算
-  输出
   -  $F_i$ 运算结果

## 3 存储系统

### 3.1 存储器的层次结构

#### 3.1.1 存储器的分类

-  按在计算机中的作用（层次）分类

   -  主存储器（主要由 DRAM 组成）
   -  辅助存储器
   -  高速缓冲存储器（Cache， 主要由 SRAM 组成）

-  按存储介质分类

   > 本质上只有 3 种：半导体、磁、光

   -  半导体存储器 TTL、MOS $\to$ 易失
   -  磁表面存储器 磁头、载磁体
   -  磁芯存储器 硬磁材料、环状元件 $\to$ 非易失
   -  光盘存储器 激光、磁光材料

-  按存取方式分类

   -  存取时间与物理地址无关（随机访问）
      -  随机存储器（RAM） 在程序的执行过程中可读可写
      -  只读存储器（ROM） 在程序的执行过程中只读
   -  存取时间与物理地址有关（串行访问）
      -  顺序存取存储器 磁带
      -  直接存取存储器 磁盘

-  按信息的可保存性分类

   -  易失性存储器 断电后存储信息即消失的存储器，如 RAM
   -  非易失性存储器 断电后信息仍然保持的存储器，如 ROM、磁表面存储器、光存储器

   ::: tip 破坏性读出与非破坏性读出

   破坏性读出指某个存储单元所存储的信息被读出时，原存储信息被破坏，必须进阶一个再生的操作以便，恢复被破坏的信息

   如果没有被破坏，则为非破坏性读出

   :::

### 3.1.2 存储器的层次化结构

![PCC05.png{copyright:Wangdao}](../Images/PCC05.png)

![PCC06.png{copyright:Wangdao}](../Images/PCC06.png)

-  Cache - 主存 层次用于解决 CPU 与主存速度不匹配的问题，由硬件自动完成
-  主存 - 辅存 层次用于解决存储系统的容量问题，由硬件和操作系统共同完成

### 3.2 主存储器

#### 3.2.1 主存的性能指标

-  存储容量 = 存储字数 $\times$ 字长（前者表示寻址范围，后者表示一次存取的数据量）
-  单位成本：每位价格 = 总成本 / 总容量
-  存储速度：数据传输率 = 数据的宽度 / 存储周期
   -  存取时间 存储器的**访问时间** （读出时间 写入时间）
   -  存取周期 **连续**两次**独立**的存储器操作所需的**最小间隔时间** （读周期 写周期），它不仅包含了存取时间，还包括了恢复时间
   -  主存带宽 位/秒

#### 3.2.2 半导体芯片简介

-  半导体存储芯片的基本结构

   ![PCC07.png{copyright:Wangdao}](../Images/PCC07.png)

   -  片选线 确定哪个存储芯片被选中
   -  地址线 单向
   -  数据线 双向

-  半导体存储芯片的译码驱动方式

   -  线选法

      不需要地址译码器，但是不能充分利用系统的存储器空间，将需要很庞大的地址线数

   -  译码片选法

      利用少量地址线（$\log_2 n$）完成片选，比如利用 8 片 $8K \times 8bit$ 的存储芯片组成 $64K \times 8bit$ 的存储器，则可将 13bit 作为片内寻址信号，剩余 3bit 作为片选信号，将该 3bit 接入译码器即可得到 8bit 的片选信号，比如 000 选中第 1 片，会在第一片片选线处产生一个低电平，其余 7 片均为高电平

#### 3.2.3 随机存取存储器（RAM）

-  静态 RAM（SRAM）

   -  存储元 双稳态**触发器**
   -  易失性半导体存储器（断电数据消失）
   -  非破坏性读出
   -  一般用作 Cache
   -  特点
      -  存取速度快
      -  集成度低，功耗较大

-  动态 RAM（DRAM）

   -  存储元 栅极**电容**上的电荷
   -  与 SRAM 比需要的晶体管更少，容易集成、价位低、容量大、功耗低，但速度慢一些，一般用于主存
   -  电容上的电荷一般只能维持 1~2ms，故每隔一段时间就需要刷新（通常取 2ms），刷新只与**行地址**有关，每次刷新刷新一行数据，而不是某一存储单元数据

      -  **集中刷新（存取周期为 0.5μs）**

         在一个刷新周期内，利用一段固定的时间，以此对存储器所有行进行逐一再生

         存在死区，那段时间 CPU 是无法读写数据的

      -  **分散刷新（存取周期为 1μs）**

         一个存储器的系统工作周期分为两部分：前半部分正常读、写或保持，后半部分用于刷新某一行

         不存在死区，但由于过度刷新，效率降低

      -  **分散刷新与集中刷新相结合（异步刷新）**

         每 15.6μs 刷新一行，2ms 刚好刷新 128 行，如果将刷新安排在指令译码阶段，不会出现死区

-  存储器的读、写周期

   -  RAM 的读周期 片选线 $\overline{CS}$ 低电平、写允许信号 $\overline{WE}$ 高电平
   -  RAM 的写周期 片选线 $\overline{CS}$ 低电平、写允许信号 $\overline{WE}$ 低电平

   都要保持到输出/输出稳定

-  动态 RAM 和静态 RAM 的比较

   |            | DRAM     | SRAM   |
   | ---------- | -------- | ------ |
   | 存储原理   | 电容     | 触发器 |
   | 刷新       | 有       | 无     |
   | 送行列地址 | 分两次送 | 同时送 |
   | 速度       | 低       | 高     |
   | 集成度     | 高       | 低     |
   | 芯片引脚   | 少       | 多     |
   | 功耗       | 小       | 大     |
   | 价格       | 低       | 高     |
   | 主要用途   | 主存     | 缓存   |

#### 3.2.3 只读存储器（ROM）

-  掩模 ROM（MROM）

   制造商写入，无法更改

   -  行列选择线交叉处有 MOS 管为“1”
   -  行列选择线交叉处无 MOS 管为“0”

-  PROM（一次性编程）

   用户可利用专门的设备进行写入，且不可修改

   -  熔丝断为“0”
   -  熔丝未断为“1”

-  EPROM（多次性编程）

   N 型沟道浮动栅 MOS 电路，紫外线全部擦洗

   -  D 端加正电压 形成浮动栅 S 与 D 不导通为“0”
   -  D 端不加正电压 不形成浮动栅 S 与 D 导通为“1”

-  EEPROM（多次性编程）

   -  电可擦写
   -  局部擦写
   -  全部擦写

-  Flash Memory(闪速型存储器)

   既可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写，且擦除重写的速度快

-  固态硬盘（Solid State Drives, SSD）

   基于闪存，由控制单元和存储单元组成

#### 3.2.4 主存储器与 CPU 的连接

-  连接原理

   主存通过数据总线、地址总线、控制总线与 CPU 连接

   -  数据总线 位数与工作频率的乘积正比于数据传输率
   -  地址总线 位数决定了可寻址的最大内存空间
   -  控制总线 指出总线周期的类型和本次输入/输出操作完成的时刻

-  主存容量的扩展

   -  位扩展法（增加存储字长）

      比如用 2 片`1K X 4位`存储芯片组成`1K X 8位`的存储器，需求是 10 根地址线、8 根数据线，材料是 10 根地址线、4 根数据线，所以就需要将两个芯片地址线直接接入，而数据线则是各占一半，以达到对某一地址数据同时进行读写

      ![PCC08.png{copyright:MOOC}](../Images/PCC08.png)

   -  字扩展法

      比如用 2 片`1K X 8位`存储芯片组成`2K X 8位`的存储器，需求是 11 根地址线、8 根数据线，材料是 10 根地址线、8 根数据线，数据线直接接入就好，而多出来的那根地址线可作为片选择线（CS），便可对两个存储芯片地址进行衔接

      ![PCC09.png{copyright:MOOC}](../Images/PCC09.png)

   -  字、位同时扩展法

      比如用 8 片`1K X 4位`存储芯片组成`4K X 8位`的存储器，先考虑位扩展，每组用 2 个存储芯片组成`1K X 8位`的存储器，然后再考虑字扩展，利用片选译码将额外两根地址线分配到四组存储器中

      ![PCC10.png{copyright:MOOC}](../Images/PCC10.png)

-  存储器与 CPU 的连接
   -  合理选择存储芯片
   -  地址线的连接
   -  数据线的连接
   -  读/写命令线的连接 $\overline{WE}$ 低电平为写，高电平为读
   -  片选线的连接 访存控制信号（$\overline{MREQ}$）低电平有效
   -  其他 时序、负载

#### 3.2.5 提高访存速度的措施

解决 CPU 速度与存储体访问速度不匹配问题

-  采用高速器件
-  采用层次结构 Cache - 主存
-  调整主存结构

   -  采用并行技术

      **双端口 RAM** 同一个存储器有左、右两个独立的端口，分别具有两组互相独立的地址线、数据线和读写控制线，但是如果两端同时访问同一个地址，并且其中一个在写数据，就会发生错误，为解决该问题，可设一个 $\overline{BUSY}$ 位

   -  多模块存储器

      -  单体多字系统 增加存储字长，但这样使得存储字作为整体，产生了很多麻烦
      -  多体并行系统

         -  **高位交叉** 适合提供存储体容量，并不适合提高存储体带宽，但也给并行存储提供了基础
         -  **低位交叉** 各个体轮流编址，适合提高存储体带宽，多存储体轮流存取，解决了 CPU 与存储器速度差异的问题

         ::: tip 为什么低位交叉可以提高存储器带宽？

         首先我们回顾存取周期（存取时间 + 恢复时间），恢复时间其实也占了很大一部分，如果我们使用高位交叉，因为连续的地址是在同一个模块的，所以读取完一个字后，需要等待该模块恢复后才能继续读下一个字

         而低位交叉就不一样啦，我们可以像流水线一样连续读取数据，因为连续编址的两个字并不是在同一个模块的，我们不需要等待它恢复就可以读下一个模块，所以它大大提升了存储器带宽

         :::

   -  高性能存储芯片

      -  SDRAM(同步 DRAM)

         在系统时钟的控制下进行读出和写入

      -  RDRAM

      -  带 Cache 的 DRAM

         有利于*猝发式读取*

### 3.3 高速缓冲存储器

解决 CPU 与主存速度不匹配问题

#### 3.3.1 程序访问的局部性原理

-  **时间局部性**：是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问

-  **空间局部性**：是指一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被访问

#### 3.3.2 Cache 的基本工作原理

-  主存和缓存的编址

   主存和缓存按块存储，块的大小相同

-  命中与未命中

   -  读
      -  命中则对 Cache 进行读操作
      -  未命中则访问主存，并 ==将此字所在的块一次性从主存调入 Cache==（若 Cache 未满则调入，若满则执行替换算法并调入）
   -  写

      > 全写法与非写分配法合用，写分配法与写会法合用

      -  命中

         -  全写法（写直通法）

            Cache 与主存一直同步，实现简单但容易频繁对某个内存写入

         -  写回法

            Cache 在替换时才写回，虽然解决了上面的频繁写的问题，但复杂且使得多核（每个核心带 Cache）Cache 不同步等问题

      -  未命中

         -  写分配法

            加载目标写入块到 Cache 中，在 Cache 中进行写入

         -  非写分配法

            只写入主存，不进行调块

*  Cache 的命中率：与 Cache 的容量与块长有关
*  Cache-主存系统的效率（时间比）

#### 3.3.3 Cache 和主存的映射方式

| 方法       | 特点                                                     | 优缺点             |
| ---------- | -------------------------------------------------------- | ------------------ |
| 直接映射   | 某一主存块**只能固定**映射到**某一**缓存块               | 不灵活、速度快     |
| 全相联映射 | 某一主存块**能**映射到**任一**缓存块                     | 利用率高、速度慢   |
| 组相联映射 | 某一主存块**只能**映射到**某一**缓存**组**中的**任一块** | 两者折中，使用较多 |

#### 3.3.4 Cache 中主存块的替换算法

-  随机算法 随机地确定替换的 Cache 块
-  先进先出（FIFO）算法 并没有提现程序的局部性原理
-  近期最少使用（LRU）算法
-  最不经常使用算法

#### 3.3.5 Cache 的改进

-  增加 Cache 的级数（L1、L2、L3 Cache）
-  统一缓存和分立缓存 $\to$ 指令 Cache 与数据 Cache 分立

### 3.4 辅助存储器

解决主存容量问题

#### 3.4.1 概述

-  特点 不直接与 CPU 交换信息
-  磁表面存储器的技术指标

   -  记录密度 道密度 位密度
   -  存储容量
   -  平均寻址时间 寻道时间 + 等待时间

      辅存的速度 = 寻址时间 + 磁头读写时间

   -  数据传输率

      误码率 出错信息位数与读出信息的总位数比值

#### 3.4.2 硬磁盘存储器 <Badge text="~" type="tip"/>

-  硬磁盘存储器的类型
   -  固定磁头和移动磁头
   -  可换盘和固定盘
-  硬磁盘存储器结构

   主机 磁盘控制器 磁盘驱动器 盘片

   -  磁盘驱动器
   -  磁盘控制器
      -  接收主机发来的命令，转换成磁盘驱动器的控制命令
      -  实现主机和驱动器之间的数据格式转换 \* 控制磁盘驱动器读写
         是主机与磁盘驱动器之间的接口 3. 盘片 由硬质铝合金材料制成

#### 3.4.3 软磁盘存储器 <Badge text="~" type="tip"/>

-  与硬盘的对比

   |      | 硬盘                     | 软盘     |
   | ---- | ------------------------ | -------- |
   | 速度 | 高                       | 低       |
   | 磁头 | 固定、活动               | 活动     |
   |      | 浮动                     | 接触盘片 |
   | 盘片 | 固定盘、盘组大部分不可换 | 可换盘片 |
   | 价格 | 高                       | 低       |
   | 环境 | 苛刻                     |          |

-  软盘片

   由聚酯薄膜制成，不过反正没人用啦已经……

#### 3.4.4 光盘存储器 <Badge text="~" type="tip"/>

-  概述

   采用光存储技术 利用激光写入和读出

   -  第一代光存储技术 采用非磁性介质 不可采写
   -  第二代光存储技术 采用磁性介质 可擦写

-  光盘的存储原理

   -  只读型和只写一次型 热作用（物理或化学变化）
   -  可擦写光盘 热磁效应

#### 3.4.5 虚拟存储器

详情见[·计算机操作系统 - 虚拟存储器·](./Operating_System.html#_4-6-虚拟存储器的基本概念)章节

虚拟存储器与 Cache 的比较

-  相同点

   -  最终目标都是为了提高系统性能
   -  都把数据化划分为小信息块，并作为基本的传递单位
   -  都有地址的映射、替换算法、更新策略等问题
   -  依据程序访问的局部性原理应用“快速缓存的思想”，将相对活跃的数据放在相对高速的部件中

-  不同点

   -  解决问题
      -  Cache 主要解决系统速度
      -  而虚存主要解决主存容量
   -  实现方式
      -  Cache 全由硬件实现，是物理存储器
      -  虚存由 OS 和硬件共同实现，是逻辑存储器
   -  不命中时对性能的影响

      -  CPU 速度约为 Cache 10 倍
      -  主存速度约为硬盘 100 倍以上

      故虚存系统不命中对系统性能影响更大

   -  与 CPU 的连接
      -  Cache 与主存都有与 CPU 的直接通路，如果不命中 CPU 能和主存直接通信，同时将数据调入 Cache
      -  辅存与 CPU 没有直接的通路，如果不命中也要先调入主存

## 4 指令系统

软硬件的交界面，软件调用指令集中的指令，让 CPU 执行这些指令

### 4.1 指令格式

#### 4.1.1 指令的基本格式

`操作码字段 + 地址码字段`

-  操作码

   指出指令中该指令应该执行什么性质的操作和具有何种功能

   -  长度固定 用于指令字长较长的情况
   -  长度可变 操作码分散在指令字的不同字段中
   -  扩展操作码技术 操作码的位数随地址数的减少而增加，举个例子：

      -  4 位操作码，从 `0000`-`1110`，预留一位 `1111` 是干嘛的呢？看下面
      -  8 位操作码，从 `1111 0000`-`1111 1110`，咦又是预留一位，继续看下面
      -  12 位操作码，从 `1111 1111 0000`-`1111 1111 1110`，好了，现在基本上都明白了
      -  16 位操作码，从 `1111 1111 1111 0000`-`1111 1111 1111 1111`，哦这时候已经木有地址码了

      ::: tip

      -  当然，我们也可以在各个长度预留 2 位或者更多位，可以更加灵活地分配
      -  通常，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间

      :::

*  地址码

   给出被操作的信息（指令或数据）的地址

   -  零地址指令
      -  可能不需要操作数的指令
      -  可能隐含从栈顶取操作数
   -  一地址指令
      -  可能单操作数指令
      -  可能双操作数指令，隐含一个操作数在 ACC
   -  二地址指令

      即两个操作数地址

   -  三地址指令

      将两个操作数的运算结果放在第三个操作数地址内

   -  四地址指令

      将两个操作数的运算结果放在第三个操作数地址内，第四个操作数为下一条将要执行指令的地址

#### 4.1.2 指令字长

-  指令字长决定于

   -  操作码的长度
   -  操作数地址的长度
      操作数地址的个数

-  如果指令字长固定 —— 指令字长=存储字长
-  如果指令字长可变 —— 按字节的倍数变化

### 4.2 指令寻址方式

-  **形式地址** $A$ 指令字中的地址
-  **有效地址** $EA$ 操作数中的真实地址，需要形式地址与寻址特征经过一定的运算得出

> (A) 表示 A 的数值，比如 $EA = (A)$ 表示有效地址为地址 A 处所存储的数值（也就是说 `()` 有点类似于 C 语言中的取内容符 `*`）

#### 4.2.1 指令寻址

寻找**下一条将要执行的指令地址**

-  顺序寻址 $(PC) + 1 \to PC$（这里这个“1”是指指令长度，要考虑定长和非定长的情况）
-  跳跃寻址 由转移指令指出（比如 JMP）

#### 4.2.2 数据寻址

寻找**操作数的地址**，指令格式如 `操作码 寻址特征 形式地址A`，其中寻址特征标志了使用以下哪种寻址方式

-  隐含寻址

   操作数地址隐含在操作码中（某个操作数隐含在某个寄存器中，比如 ADD 指令一个操作数隐含在 ACC 中）

   -  指令字中少了一个地址字段，可缩短指令字长

-  立即寻址

   形式地址 A 中存的不是操作数的地址，而是操作数本身

   -  指令执行阶段不访存
   -  A 的位数限制了立即数的范围

-  直接寻址

   $EA = A$，有效地址就是形式地址 A

   -  执行阶段访问一次存储器
   -  A 的**位数决定**了该指令操作数的**寻址范围**
   -  操作数的地址不易修改（必须修改 A）

-  间接寻址

   $EA = (A)$，有效地址由形式地址间接提供

   -  执行指令阶段 2 次访存，访问速度过慢，一般使用寄存器间接寻址替代
   -  可扩大寻址范围
   -  便于编制程序

-  寄存器寻址

   $EA = R_i$，有效地址即为寄存器编号

   -  执行阶段不访存，只访问寄存器，执行速度快
   -  寄存器个数有限，可缩短指令字长

-  寄存器间接寻址

   $EA = (R_i)$ 有效地址在寄存器中

   -  有效地址在寄存器中，操作数在存储器中，执行阶段访存
   -  便于编制循环程序

-  相对寻址

   $EA = (PC) + A$，A 是相对于当前指令的位移量（可正可负，补码）

   -  A 的位数决定操作数的寻址范围
   -  便于程序浮动
   -  广泛用于转移指令
   -  执行指令之前 PC 就已经自增了

-  基址寻址

   -  采用专用寄存器 BR 作基址寄存器

      $EA = (BR) + A$，BR 为基址寄存器

      -  免箱操作系统，主要用于解决程序逻辑空间与存储器物理空间的无关性
      -  可扩大寻址范围
      -  有利于多道程序
      -  BR 内容由操作系统或管理程序确定
      -  在程序的执行过程中 BR 内容不变，形式地址 A 可变，但形式地址 A 位数较短

   -  采用通用寄存器作基址寄存器

      -  由用户指定哪个通用寄存器作为基址寄存器
      -  基址寄存器的内容由操作系统确定
      -  在程序的执行过程中 $R_0$ 内容不变， ==形式地址 A 可变==

-  变址寻址

   $EA = (IX) + A$，IX 为变址寄存器（专用），通用寄存器也可以作为变址寄存器

   -  可扩大寻址范围
   -  IX 的内容由用户给定
   -  在程序的执行过程中 IX 内容可变， ==形式地址 A 不可变==
   -  便于处理数组问题

-  堆栈寻址

   隐含使用栈顶指针 $SP$ 处的操作数

   -  硬堆栈 多个寄存器
   -  软堆栈 指定的存储空间

| 寻址方式           | 有效地址        | 访存次数 |
| ------------------ | --------------- | -------- |
| 隐含寻址           | 程序指定        | 0        |
| 立即寻址           | A 即是操作数    | 0        |
| 直接寻址           | $EA = A$        | 1        |
| 一次间接寻址       | $EA = (A)$      | 2        |
| 寄存器寻址         | $EA = R_i$      | 0        |
| 寄存器一次间接寻址 | $EA = (R_i)$    | 1        |
| 相对寻址           | $EA = (PC) + A$ | 1        |
| 基址寻址           | $EA = (BR) + A$ | 1        |
| 变址寻址           | $EA = (IX) + A$ | 1        |

### 4.3 CISC 和 RISC 的基本概念

指令系统发展的两个不同方向

-  CISC 增强原有指令的功能，实现软件功能的硬化
-  RISC 减少指令种类和简化指令功能，提高指令的执行速度

#### 4.3.1 复杂指令系统计算机（CISC）

-  系统指令复杂庞大，各种指令使用频度相差大
-  指令长度不固定、指令格式种类多、寻址方式多
-  访存指令不受限制
-  大多数指令需要多个时钟周期执行完毕
-  采用微程序控制器

#### 4.3.2 精简指令系统计算机（RISC）

典型程序中程序 80%的语句仅仅使用处理机中 20%的指令

所以，可以使用 20%的简单指令组合不常用的 80%的指令功能

-  选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合
-  指令长度固定、指令格式种类少、寻址方式少
-  只有 LOAD/STORE 指令访存
-  CPU 中有多个通用寄存器
-  采用流水技术 一个时钟周期内完成一条指令
-  采用组合逻辑实现控制器

由于需要对一些老机器兼容，所以 CISC 的设计结构是不可避免的，但是 RISC 有着更高的实用性，所以现代 CISC 结构的 CPU 融合了很多 RISC 的成分，其性能差距越来越小

#### 4.3.3 CISC 和 RISC 的比较

-  RISC 更能充分利用 VLSI 芯片的面积
-  RISC 更能提高计算机运算速度
-  RISC 便于设计，可降低成本，提高可靠性
-  RISC 不易实现指令系统兼容
-  RISC 有利于编译程序代码优化

|                  | CISC                                 | RISC                                 |
| ---------------- | ------------------------------------ | ------------------------------------ |
| 指令系统         | 复杂，庞大                           | 简单，精简                           |
| 指令数目         | 一般大于 200 条                      | 一般小于 100 条                      |
| 指令字长         | 不固定                               | 定长                                 |
| 可访存指令       | 不加限制                             | 只有 Load/Store 指令                 |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量   | 较少                                 | 多                                   |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
| 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |

## 5 中央处理器

### 5.1 CPU 的功能和基本结构

#### 5.1.1 CPU 的功能

-  控制器的功能

   -  指令控制 取指、分析、执行
   -  操作控制 控制程序输入及结果的输出
   -  时间控制
   -  中断处理

-  运算器的功能

   -  数据加工 实现算术运算和逻辑运算

#### 5.1.2 CPU 的基本结构

-  运算器

   -  算术逻辑单元（ALU） 算术/逻辑运算
   -  暂存寄存器 暂存从主存读来的数据
   -  累加寄存器（ACC） 暂存 ALU 的结果，并可作为加法的一个输入
   -  通用寄存器组 AX、BX、CX、DX、SP 等，SP 是堆栈指针
   -  程序状态字寄存器（PSW） 保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息
   -  移位器 对操作数或运算结果进行移位运算
   -  计数器（CT） 控制乘除运算的操作步数（判断乘除法是否已结束）

-  控制器

   -  程序计数器（PC） 指出下一条指令在主存中的地址
   -  指令寄存器（IR） 保存当前正在执行的指令
   -  指令译码器 对**操作码**字段进行译码，向控制器提供特定的操作信号
   -  存储器地址寄存器（MAR） 存储所要访问的主存单元的地址
   -  存储器数据寄存器（MDR） 存储向主存写入的信息或者从主存读出的信息
   -  时序系统 产生**各种时序信号**，由统一时钟分频得到
   -  微操作信号发生器 根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号

### 5.2 中断系统

#### 5.2.1 引起中断的各种因素

-  人为设置的中断 如**转管指令**
-  程序性事故 溢出、操作码不能识别、除法非法
-  硬件故障
-  I/O 设备
-  外部事件 用**键盘中断**现行程序

#### 5.2.2 程序中断方式工作流程

-  中断请求

   中断源向 CPU 发送中断请求信号

   -  内中断和外中断
      -  外中断 指来自处理器和内存以外的部件引起的中断
      -  内中断 指在处理器和内存内部产生的中断
   -  硬件中断和软件中断
      -  硬件中断 通过外部的硬件产生的中断
      -  软件中断 通过某条指令产生的中断
   -  非屏蔽中断和可屏蔽中断
      -  非屏蔽中断 即便关中断也会响应
      -  可屏蔽中断 可被关中断屏蔽

-  中断判优

   按照一定的优先级进行判优，一般来说硬件故障中断最高级，其次是软件中断，非屏蔽中断优于可屏蔽中断，DMA 请求优于 I/O 设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备

-  CPU 响应中断的条件

   -  中断源有中断请求
   -  CPU 允许中断及开中断
   -  一条指令执行完毕，且没有更急迫的任务

-  中断隐指令

   CPU 响应中断后，**经过某些操作**，转而执行中断服务程序，这些操作并不是真正的指令，由硬件直接实现

   -  关中断 保护中断现场（寄存器中的内容），防止被新的中断打断
   -  保存断点 将程序断点（即 PC 中的内容）暂存起来（入栈）
   -  引出中断服务程序 取出中断程序入口地址存入 PC

-  寻址中断服务程序

   -  硬件向量法 将中断程序入口地址存储在存储器某个位置，作为中断向量表
   -  软件查询法 通过命令来完成

-  中断处理过程

@flowstart
s=>start: （响应中断）
op1=>operation: 关中断
op2=>operation: 保存断点
op3=>operation: 中断服务程序寻址
op4=>operation: 保护现场和屏蔽字
op5=>operation: 开中断
op6=>operation: 执行中断服务程序
op7=>operation: 关中断
op8=>operation: 恢复现场和屏蔽字
op9=>operation: 开中断
op10=>operation: 中断返回
e=>end: （结束中断）

s->op1->op2->op3->op4->op4->op5->op6->op7->op8->op9->op10->e
@flowend

::: tip 为什么在执行中断服务程序前需要开中断？

这样才可以被更高优先级的中断打断，实现中断嵌套

:::

#### 5.2.3 多重中断和中断屏蔽技术

-  单重中断

   CPU 在执行中断过程中如果出现了新的更高优先级的中断请求，不予响应

-  多重中断

   又称中断嵌套，CPU 在执行中断过程中如果出现了新的更高优先级的中断请求，转而执行更高优先级的中断请求

   ![PCC22.png{copyright:Wangdao}](../Images/PCC22.png)

   -  实现多重中断的要求
      -  中断服务程序前进行“开中断”（即上节所述）
      -  优先级高的中断源有权中断优先级低的中断源
   -  屏蔽字

      使用实例说明：优先级：$D>A>C>B$，则屏蔽字应为

      ![PCC23.png{copyright:Wangdao}](../Images/PCC23.png)

### 5.3 指令执行过程

#### 5.3.1 指令周期

CPU 从主存中每取出并执行一条指令所需的全部时间称为指令周期，即 CPU 完成一条指令的时间

-  机器周期、节拍（状态）组成多级时序系统

   -  一个**指令周期**包含若干个**机器周期**
   -  一个**机器周期**包含若干个**时钟周期**

   ![PCC18.png{copyright:Wangdao}](../Images/PCC18.png)

-  完整的指令周期

   一个完整的指令周期可能包含 ==取指周期==、（ ==间址周期==）、 ==执行周期==、（ ==中断周期==）四部分（括号中为不一定出现的）

   -  取指周期 取指令
   -  间址周期 取有效地址
   -  执行周期 执行指令
   -  中断周期 中断响应

#### 5.3.2 指令周期的数据流

-  取指周期

   任务：根据 PC 中的内容从主存中取出指令代码并存入 IR

   ![PCC19.png{copyright:Wangdao}](../Images/PCC19.png)

   -  $PC \to MAR \to$ 地址总线
   -  $CU$ 发出控制信号 $\to$ 控制总线 $\to$ 主存
   -  主存 $\to$ 数据总线 $\to MDR \to IR$ （存放指令）
   -  $CU$ 发出读命令 $\to PC$ 内容加 1

-  间址周期

   任务：取操作数的有效地址（这里以一次间址为例）

   ![PCC20.png{copyright:Wangdao}](../Images/PCC20.png)

*  $Ad(IR)$ $\to$ $MAR$ $\to$ 地址总线 $\to$ 主存

   ::: tip

   -  由于此时（刚刚取指后嘛） $IR$ 与 $MDR$ 中的数据相同，所以第一步使用 $Ad(MDR)$ 也是可以的
   -  $Ad$ 是取指令中的地址字段

   :::

*  $CU$ 发出读命令 $\to$ 控制总线 $\to$ 主存
*  主存 $\to$ 数据总线 $\to MDR$ （存放有效地址）

*  执行周期

   根据指令不同而不同，没有统一的数据流向

*  中断周期

   任务：处理中断请求，假设程序断点存入堆栈，并用 $SP$ 指示栈顶地址

   ![PCC21.png{copyright:Wangdao}](../Images/PCC21.png)

   -  $CU$ 控制 $SP$ 减一，$SP \to MAR \to$ 地址总线 $\to$ 主存

      ::: tip

      中断周期中进栈操作是将 SP 减一而不是加一，因为计算机中的栈是向低地址增加的

      :::

   -  $CU$ 发出写命令 $\to$ 控制总线 $\to$ 主存
   -  $PC \to MDR \to$ 数据总线 $\to$ 主存（程序断点存入主存）
   -  $CU$（中断服务程序的入口地址）$\to PC$

#### 5.3.3 指令执行方案

-  单指令周期

   使用定长指令周期，所以指令周期取决于最长的指令执行时间，降低整个系统运行速度

-  多指令周期

   对不同指令选用不同的执行步骤，指令之间仍然串行执行

-  流水线方案

   指令之间可以并行执行，理想情况下每个时钟脉冲周期执行指令中的一个执行过程

### 5.4 数据通路的功能和基本结构

---

新旧分界线

---

## 3 系统总线

### 3.1 总线的基本概念

#### 3.1.1 为什么要用总线

避免分散连接使得 CPU 难以设计
如果是分散连接，CPU 要做好多好多引脚，而且每增加一种设备 CPU 就要加一些引脚，可扩展性就很差啦

#### 3.1.2 总线(BUS)是什么

1. 总线是连接各个部件的信息传输线，是各个部件共享的传输介质
2. 总线十分繁忙，同一时刻只能有一对设备使用总线，因此总线容易成为瓶颈，但是其结构简单、可扩展性好，故使用该总线
   另外哈弗总线及其原理参见[PIC 哈弗总线](./PIC.md)
3. 一条总线的传输单元仍然是位，并行才能同时传输多位
4. 同时只能有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息

#### 3.1.3 总线上信息的传送

1. 串行
   `-------`
2. 并行 只适合短距离运输

```
------
------
------
------
```

而且现在串行速率比并行高，参考->[为什么目前的串行比并行传输快](https://www.cnblogs.com/juner/p/5514615.html)

#### 3.1.4 总线结构的计算机举例

1. 单总线结构框图 易成为瓶颈
2. 面向 CPU 的双总线结构框图
   1. I/O 总线
   2. M 总线
3. 以存储器为中心的双总线结构框图
   1. 存储总线
   2. 系统总线

### 3.2 总线的分类

1. 片内总线 芯片内部的总线
2. 系统总线 计算机各部件之间的信息传输线
   1. **_数据总线_** **双向** 与机器字长、存储字长有关
   2. **_地址总线_** **单向** 与存储地址、I/O 地址有关
   3. **_控制总线_** **有出 有入**
3. 通信总线
   用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信
   传输方式也分为串行通信总线与并行通信总线

### 3.3 总线特性及性能指标

#### 3.3.1 总线物理实现

BUS 印刷在主板上 各模块插在主板上

#### 3.3.2 总线特性

1. 机械特性 尺寸、形状、管脚数、排列顺序
2. 电气特性 传输方向和有效的电平范围
3. 功能特性 每根传输线的功能 可分为地址、数据、控制、状态反馈
4. 时间特性 信号的时序关系

#### 3.3.3 总线的性能指标

1. 总线宽度 数据线的根数
2. 标准传输率 每秒传输的最大字节数（MBps）
3. 时钟同步/异步 同步、不同步
4. 总线复用 地址线与数据线复用，可以减少芯片管脚数
5. 信号线数 地址线、数据线、和控制线的总和
6. 总线控制方式 突发、自动、仲裁、逻辑、计数
7. 其他指标 负载能力

#### 3.3.4 总线标准

### 3.4 总线结构

#### 3.4.1 单总线结构

#### 3.4.2 多总线结构

1. 双总线结构
2. 三总线结构

   1. 形式 1
      主存与**高速外设**间额外增加一条**DMA 总线**，使得高速外设得以直接与主存交换数据，而低速外设仍需要通过 I/O 总线并由 CPU 调度进而与主存交换数据 2. 形式 2
      主存与 CPU 之间增加一个**Cache**，Cache 与 CPU 由局部总线连接，由局部 I/O 控制器控制
      此外，一条扩展总线连接所有的外围设备，使得外设速度较慢

3. 四总线结构
   结合三总线形式 1 和 2 的优点，在形式 2 的 Cache 上扩展出一个高速总线，高速总线连接高速设备，另外高速总线扩展出一个扩展总线进而连接低速外设

#### 3.4.3 总线结构举例

1. 传统微型机总线结构
2. VL-BUS 局部总线结构
3. PCI 总线结构
4. 多层 PCI 总线结构

### 3.5 总线控制

#### 3.5.1 总线判优控制

1. 基本概念
   -  主设备 对总线有**控制权**
   -  从设备 **响应**从主设备发来的总线命令
   -  总线判优控制
   ```
               |-链式查询
    |---集中式< -计数器定时查询
   <           |-独立请求方式
    |---分布式
   ```
1. 链式查询
   **BS-总线忙 BR-总线请求 BG-总线同意**
   I/O 接口通过 BR 请求总线使用，BG 逐个向下查询，总线使用权交给遇到的第一个请求的接口，然后这个接口通过 BS 设置总线忙
   特点：优先级由连接方式事先确定，如果某设备优先级低，很可能他的请求一直得不到应答；而且对电路故障非常敏感；有个优点就是简单啦、增删设备很容易 blabla
1. 计数器定时查询
   I/O 接口通过 BR 请求总线使用，计数器循环累加从设备地址线向下查询，直到遇到第一个请求的接口，将总线使用权交由它，然后这个接口通过 BS 设置总线忙
   特点：优先级设置很灵活；需要$[log_2n]$条设备地址线
1. 独立请求方式
   每个接口都与控制机构有连接，控制机构有排队器

#### 3.5.2 总线通信控制

1. 目的
   解决通信双方**协调配合**问题
2. 总线传输周期
   1. 申请分配阶段 **主模块申请**，总线仲裁决定
   2. 寻址阶段 主模块向从模块**给出地址**和**命令**
   3. 传数阶段 主模块和从模块**交换数据**
   4. 结束阶段 主模块**撤销有关信息**
3. 总线通信的四种方式
   1. 同步通信 由**统一时标**控制数据传送 _需要一个时钟_
   2. 异步通信 采用**应答方式**，没有公共时钟标准 _不互锁、半互锁、全互锁_ 要求各模块速度匹配，不然受限于最低速的模块，因此也导致了长度不能过长
   3. 半同步通信 **同步、异步结合** 在同步基础上增加 WAIT 信号，若其位于低电平则等待一个时钟周期后再次检测
   4. 分离式通信 充分**挖掘**系统**总线每个瞬间**的潜力
      1. 主模块申请占用总线，使用完后即放弃总线的使用权
      2. ~~从模块准备数据~~，解决从模块准备数据仍占用总线的问题
      3. 从模块申请占用总线（或者说这时它已经是主模块了），将各种信息送至总线上
      4. 特点：各模块有权申请占用总线；同步通信；准备数据不占用宗霞；总线被占用时无空闲

## 5 输入输出系统

### 5.1 概述

#### 5.1.1 输入输出系统的发展概况

1. 早期
   分散连接
   CPU 和 I/O 设备穿行工作 程序查询方式
2. 接口模块和 DMA 阶段
   总线连接
   CPU 和 I/O 设备并行工作 （中断方式 DMA 方式 ）
3. 具有通道结构的阶段
4. 具有 I/O 处理机的阶段

#### 5.1.2 输入输出系统的组成

1. I/O 软件
   1. I/O 指令 CPU 指令的一部分
      操作码 命令码 设备码
   2. 通道指令 通道自身的指令
      指出数组的首地址、传送字数、操作命令
2. I/O 硬件
   设备 I/O 接口
   设备 设备控制器 通道

#### 5.1.3 I/O 设备与主机的联系方式

1. I/O 设备编址方式
   1. 统一编址 用取数、存数指令（要求地址线足够，比如 64 位系统寻址范围足够大，完全可以使用统一编址）
   2. 不统一编址 有专门的 I/O 指令
2. 设备选址
   用设备选择电路识别是否被选中
3. 传送方式
   1. 串行
   2. 并行
4. 联络方式
   1. 立即响应
   2. 异步工作采用应答信号
      1. 并行
      2. 串行
   3. 同步工作采用同步时标
5. I/O 设备与主机的连接方式
   1. 辐射式连接 每套设备都配有一套控制线路和一组信号线，不便与增删设备
   2. 总线连接 便于增删设备

#### 5.1.4 I/O 设备与主机信息传送的控制方式

1. 程序查询方式 CPU 和 I/O 串行工作，踏步等待
2. 程序中断方式 CPU 和 I/O 部分地并行工作，但是会有保存现场和恢复现场的复杂操作
3. DMA 方式 CPU 和 I/O 并行工作，该时间 CPU 可以执行非访存的指令（指令早就取在指令缓存器啦）

**I/O 系统的自治能力越来越强**

### 5.2 外部设备

#### 5.2.1 概述

主机 I/O 接口 外设（设备控制器 机电磁光部分）
外设大致分三类

1. 人机交互设备 键盘、鼠标、打印机、显示器
2. 计算机信息存储设备 磁盘、光盘、磁带
3. 机-机通信设备 调制解调器等

#### 5.2.2 输入设备

1. 键盘
2. 鼠标
3. 触摸屏

#### 5.2.3 输出设备

1. 显示器
2. 打印机

#### 5.2.4 其他

#### 5.2.5 多媒体技术

### 5.3 I/O 接口

#### 5.3.1 概述

1. 实现设备的选择
2. 实现数据缓冲达到速度匹配
3. 实现数据串-并格式转换
4. 实现电平转换
5. 传送控制命令
6. 反映设备的状态（“忙”、“就绪”、“中断请求”）

#### 5.3.2 接口的功能和组成

1. 总线连接方式的 I/O 接口电路
   1. 设备选择线
   2. 数据线
   3. 命令线
   4. 状态线
2. 接口的功能和组成

| 功能               | 组成                                                                                               |
| ------------------ | -------------------------------------------------------------------------------------------------- |
| 选址功能           | 设备选择电路                                                                                       |
| 传送命令的功能     | 命令寄存器、命令译码器                                                                             |
| 传送数据的功能     | 数据缓冲寄存器                                                                                     |
| 反映设备状态的功能 | 设备状态标记</br>1.完成触发器 D</br>2.工作触发器 B</br>3.中断请求触发器 INTR</br>4.屏蔽触发器 MASK |

3. I/O 接口的基本组成
   ![Principles_of_computer_composition15](../Images/Principles_of_computer_composition15.png)

#### 5.3.3 接口类型

1. 按数据**传送方式**分类
   1. 并行接口
   2. 串行接口
2. 按功能**选择的灵活性**分类
   1. 可编程接口
   2. 不可编程接口
3. 按**通用性**分类
   1. 通用接口
   2. 专用接口
4. 按数据传送的**控制方式**分类
   1. 中断接口
   2. DMA 接口

### 5.4 程序查询方式

#### 5.4.1 程序查询方式的流程

1. 查询流程
2. 程序流程

#### 5.4.2 程序查询方式的接口电路

### 5.5 程序中断方式

#### 5.5.1 中断概念

外设发出中断指令后 CPU 转而执行中断服务程序

#### 5.5.2 I/O 中断的产生

CPU 与 I/O 设备部分并行工作

#### 5.5.3 程序中断方式的接口电路

1. 配置中断请求触发器和中断屏蔽触发器
   INTR=1 有请求 MASK=1 被屏蔽
2. 排队器 自左向右优先级降序排列（只有一个 1，其余全 0）
3. 中断向量地址形成部件
4. 程序中断方式接口电路的基本组成
   ![Principles_of_computer_composition16](../Images/Principles_of_computer_composition16.png)

#### 5.5.4 I/O 中断处理过程

1. CPU 响应中断的条件和时间
   1. 条件
      1. 允许中断触发器 ENIT=1
      2. 用开中断指令将 EINT 置“1”
      3. 用关中断指令将 EINT 置“0”或硬件自动复位
   2. 时间
      当 D=1 且 MASK=0 时，在每条指令执行阶段的结束前，CPU 发中断查询信号（将 INTR 置“1”）
2. I/O 中断处理过程
   略略略ヾ(๑╹◡╹)ﾉ"

#### 5.5.5 中断服务程序流程

1. 中断服务程序的流程
   1. 保护现场
      1. 程序断点的保护 中断隐指令完成（硬件的一系列操作，并不是真正的指令）
      2. 寄存器内容的保护 进栈指令
   2. 中断服务
   3. 恢复现场
   4. 中断返回
2. 单重中断和多重中断 1. 单重中断 不允许中断现行的中断服务程序 2. 多重中断 允许级别更高的中断源中断现行的中断服务程序
   两者实现上的区别仅在于中断服务程序中开中断的位置，多重中断将开中断提前，使设备服务过程中可以被中断

3. 主程序和服务程序抢占 CPU 示意图
   略略略(\*/ω＼\*)
   宏观上 CPU 和 I/O 并行工作
   微观上 CPU 中断现行程序为 I/O 服务

### 5.6 DMA 方式

#### 5.6.1 DMA 方式的特点

1. DMA 和程序中断两种方式的数据通路
   ![Principles_of_computer_composition17](../Images/Principles_of_computer_composition17.png)
   中断方式需要 CPU 中的寄存器，DMA 一般连接高速设备
2. DMA 与驻村交换数据的三种方式
   1. 停止 CPU 访问主存
      控制简单但未充分发挥 CPU 对准的利用率
   2. 周期挪用（或周期窃取）
      CPU 与 DMA 同时访存时 DMA 优先级更高
   3. DMA 与 CPU 交替访问
      不需要申请建立和归还总线的使用权，简单是简单，但利用率也很低

#### 5.6.2 DMA 接口的功能和组成

1. DMA 接口功能
   1. 向 CPU 申请 DMA 传送
   2. 处理总线控制权的转交
   3. 管理系统总线、控制数据传送
   4. 确定数据传送的首地址和长度
      修正传送过程中的数据地址和长度
   5. DMA 传送结束时，给出操作完成信号
2. DMA 接口组成
   略略略(￣ ▽ ￣)／

#### 5.6.3 DMA 的工作过程

1. DMA 传送过程
   1. 预处理
      1. 通知 DMA 控制逻辑传送方向
      2. 设备地址（DAR）
      3. 主存地址（AR）
      4. 传送字数（WC）
   2. 数据传送
   3. 后处理
      1. 校验送入主存的数是否正确
      2. 是否继续用 DMA
      3. 测试传送过程是否正确，错则转诊断程序
      4. 由中断服务程序完成
2. DMA 接口与系统的连接方式
   1. 具有公共请求线的 DMA 请求
   2. 独立的 DMA 请求
      类似于[总线的判优控制](#351-总线判优控制)
3. DMA 方式与程序中断方式的比较

| &nbsp;       | 中断方式     | DMA 方式     |
| ------------ | ------------ | ------------ |
| 数据传送     | 程序         | 硬件         |
| 响应时间     | 指令执行结束 | 存取周期结束 |
| 处理异常情况 | 能           | 不能         |
| 中断请求     | 传送数据     | 后处理       |
| 优先级       | 低           | 高           |

#### 5.6.4 DMA 接口的类型

1. 选择型
   在物理上连接多个设备，在逻辑上只允许连接一个设备
2. 多路型
   在物理上连接多个设备，在逻辑上允许多个设备同时工作
   ![Principles_of_computer_composition18](../Images/Principles_of_computer_composition18.png)

## 8 CPU 的结构和功能

### 8.3 指令流水

#### 8.3.1 如何提高机器速度

1. 提高访存速度
   -  高速芯片 Cache
   -  多体并行
2. 提高 I/O 和主机之间的传送速度
   -  中断
   -  DMA
   -  通道
   -  I/O 处理机
   -  多总线
3. 提高运算器速度
   -  高速芯片
   -  改进算法
   -  快速进位链

-  提高整机处理能力
   -  高速器件
   -  改进系统结构，开发系统的并行性

#### 8.3.2 系统的并行性

1. 并行的概念
   -  并发 两个或两个以上事件在**同一时间段**发生
   -  同时 两个或两个以上事件在**同一时刻**发生（时间上互相重叠）
2. 并行性的等级
   -  过程级（程序、进程） 粗粒度 软件实现
   -  指令级（指令之间、指令内部） 细粒度 硬件实现

#### 8.3.3 指令流水的原理

1. 指令的串行执行
   总有一个部件空闲
2. 指令的二级流水
   取指和执行阶段时间上**完全重叠**
   指令周期**减半**，速度提高**一倍**
3. 影响指令流水效率加倍的因素
   1. 执行时间 > 取指时间
      取指令部件 -> 指令部件缓冲区 -> 执行指令部件
   2. **条件转移指**令对指令流水的影响
      必须等上调指令执行结束，才能确定下条指令的地址，造成时间损失
      解决：猜测法等
4. 指令的内存流水
   -  FI 取指令
   -  DI 指令译码
   -  CO 形成操作数的地址
   -  FO 取操作数
   -  EI 执行
   -  WO 结果的写回

#### 8.3.4 影响指令流水线性能的因素

1. 结构相关 不同指令争用同意功能部件产生资源冲突
   解决方法：
   -  停顿
   -  指令存储器和数据存储器分开（哈弗结构） \* 指令预取技术（适用于访存周期短的情况）
2. 数据相关
   不同指令因重叠操作，可能改变操作数

   -  写后读相关（RAW）
   -  读后写相关（WAR） \* 写后写相关（WAW）

      解决办法：

      -  后推法
      -  改用旁路技术

3. 控制相关
   由**转移指令**引起

#### 8.3.5 流水线性能

1. 吞吐率
   单位时间内流水线所完成指令或输出结果的数量，设 m 段的流水线各段时间为 $\Delta t$
   -  最大吞吐率
      $T_{pmax}=\frac{1}{\Delta t}$
   -  实际吞吐率
      连续处理 n 条指令的吞吐率为
      $T_p=\frac{n}{m\cdot\Delta} t+(n-1)\dot\Delta t$
2. 加速比$S_p$
   m 段的流水线的速度与等功能的非流水线的速度之比
   设 m 段的流水线各段时间为$\Delta t$
   完成 n 条指令在等效的非流水线上共需$T=n\cdot\Delta t+(n-1)\cdot\Delta t$
   完成 n 条指令在等效的非流水线上共需$T^{'}=nm\cdot\Delta t$
   则$S_p=\frac{nm\cdot\Delta t}{m\cdot\Delta t+(n-1)\cdot\Delta t}=\frac{nm}{m+n-1}$
3. 效率
   流水线中各功能段的利用率
   由于流水线有建立时间和排空时间
   因此各功能段的设备不可能一直处于工作状态

#### 8.3.6 流水线的多发技术

1. 超标量技术
   -  每个时钟周期内可并发多条独立指令，配置多个功能部件
   -  不能调整指令的执行顺序，通过**编译优化**技术，把可并行执行的指令搭配起来
2. 超流水线技术
   -  在**一个时钟周期**内再分段，在一个时钟周期内一个功能部件使用多次
   -  不能调整指令的执行顺序，考编译程序解决优化问题
3. 超长指令字技术
   -  由编译程序挖掘出指令间潜在的并行性，**将多条能并行操作的指令组合成一条**，具有多个操作码字段的超长指令字（可达几百位）
   -  采用多个处理部件

#### 8.3.7 流水线结构

1. 指令流水结构
   -  取指令部件
   -  指令译码部件
   -  地址形成部件
   -  取操作数部件
   -  操作执行部件
   -  回写结果部件
      > 要锁存
2. 运算流水线
   完成浮点加减运算可分**对阶、尾数求和、规格化**三段
   -  对阶功能部件
   -  尾数加部件 \* 规格化部件

> 分段原则 每段操作时间尽量一致

## 9 控制单元的功能

### 9.2 控制单元的功能

#### 9.2.4 控制方式

产生不同微操作命令序列所有的时序控制方式

1. 同步控制方式
   -  任一微操作均有统一基准时标的时序信号控制
   1. 采用定长的机器周期
      -  以最长的微操作序列和最复杂的微操作作为标准
      -  机器周期内节拍数相同
   2. 采用不定长的机器周期
      -  机器周期内节拍数不等
   3. 采用中央控制和局部控制相结合的方法
2. 异步控制方式
   -  无基准时标信号
   -  无固定的周期节拍和严格地时钟同步
   -  采用**应答**方式
3. 联合控制方式
   -  同步与异步相结合
4. 人工控制方式
   1. Reset
   2. 连续和单条指令
   3. 符合停机开关

## 10 控制单元的设计

### 10.1 组合逻辑设计

#### 10.1.1 组合逻辑控制单元框图

1. CU 外特性
   CU、节拍发生器、操作码译码、标志
2. 节拍信号

#### 10.1.2 微操作的节拍安排

采用同步控制方式
一个机器周期内有 3 个节拍（时钟周期）（需要多少个节拍是需要具体分析的）
CPU 内部结构采用非总线方式

1. 安排微操作时序的原则
   1. 原则一 微操作的先后顺序不得随意更改
   2. 原则二 被控对象不同的微操作，尽量安排在一个节拍内完成
   3. 原则三 占用时间较短的微操作，尽量安排在一个节拍内完成，并允许有先后顺序
2. 取指周期微操作的节拍安排
   例：
   ![Principles_of_computer_composition37](../Images/Principles_of_computer_composition37.png)
3. 间址周期微操作的节拍安排
4. 执行周期微操作的节拍安排
5. 中断周期微操作的节拍安排

#### 10.1.3 组合逻辑设计步骤

1. 列出操作时间表
   ![Principles_of_computer_composition38](../Images/Principles_of_computer_composition38.png)
2. 写出微操作命令的最简表达式
   ![Principles_of_computer_composition39](../Images/Principles_of_computer_composition39.png)
3. 画出逻辑图

### 10.2 微程序设计

#### 10.2.1 微程序设计思想的产生

![Principles_of_computer_composition40](../Images/Principles_of_computer_composition40.png)

#### 10.2.2 微程序控制单元框图及工作原理

1. 机器指令对应的微程序
   ![Principles_of_computer_composition41](../Images/Principles_of_computer_composition41.png)
2. 微指令控制单元的基本框图
3. 工作原理
   ![Principles_of_computer_composition42](../Images/Principles_of_computer_composition42.png)
   > 可以看出，对于微指令来说执行过程是很简单的，微指令只需要形成对微操作命令的索引，而微操作命令是存储在控制存储器中的

#### 10.2.3 微指令的编码方式（控制方式）

1. 直接编码（直接控制）方式

   -  伪指令的操作控制字段中
   -  **每一位代表一个微操作指令** \* 某位为“1”表示该控制信号有效

   > 不需要译码，速度最快

2. 字段直接编码方式（显式编码）

   -  将微指令的控制字段分为若干“段”
   -  **每段经译码后发出控制信号** \* 每个字段中的命令是互斥的

   > 缩短了微指令字长，增加了译码时间

3. 字段间接编码方式（隐式编码）
   各字段译码结果不仅与本字段输入相关，还和其他字段译码结果相关

4. 混合编码
   直接编码和字段编码（直接和间接）混合使用

5. 其他

#### 10.2.4 微指令序列地址的形成

1. 微指令的下地址字段指出
2. 根据机器指令的操作码形成
3. 增量计数器
   (CMAR) + 1 -> CMAR
4. 分支转移
   操作控制字段 | 转移方式 | 转移地址
   转移方式 知名判别条件
   转移地址 指明转移成功后的去向
5. 通过测试网络
   图略
6. 由硬件产生微程序入口地址
   第一条微指令地址 由专门硬件产生
   中断周期 由硬件产生中断周期微程序首地址
7. 后续微指令形成方式原理图
   ![Principles_of_computer_composition43](../Images/Principles_of_computer_composition43.png)

#### 10.2.5 微指令格式

1. 水平型微指令
   -  一次定义并执行多个并行操作
   -  如：直接编码、字段直接编码、字段间接编码、直接和字段混合编码
2. 垂直型微指令
   -  类似机器指令操作码的方式
   -  由微操作码字段规定微指令的功能
3. 两种微指令格式的比较
   1. 水平型微指令比垂直型微指令**并行操作能力强，灵活性强**
   2. 水平型微指令执行一条机器指令所要的微指令**数目少、速度快**
   3. 水平型微指令**用较短的微程序结构喊去较长的微指令结构**
   4. 水平型微指令与机器指令**差别大**

#### 10.2.6 静态微程序设计和动态微程序设计

-  静态 微程序无需改变，采用 ROM
-  动态 通过改变微指令和微程序改变机器指令，有利于仿真，采用 EPROM

#### 10.2.7 毫微程序设计

1. 毫微程序设计的基本概念
   -  **微程序设计**用**微程序解释机器指令**
   -  **毫微程序设计**用**毫微程序解释微指令**
   -  **毫微程序与微指令**的关系好不**微指令与机器指令**的关系
2. 毫微程序控制存储器的基本组成
   ![Principles_of_computer_composition44](../Images/Principles_of_computer_composition44.png)
   毫微程序是使用垂直型微指令

#### 10.2.8 串行微程序控制和并行微程序控制

微指令层面对**取指**和**执行**的串行和并行（流水）

#### 10.2.9 微程序设计举例

略，有点长

# Reference

1. 2020 年计算机组成原理考研复习指导 - 王道
2. 《计算机组成原理》 唐朔飞
3. 《Computer Organization and Design (The Hardware/Software Interface)》 David A. Patterson, John L. Hennessy
4. 《计算机科学导论》 佛罗赞、莫沙拉夫
5. 计算机组成原理（[上](https://www.icourse163.org/course/HIT-309001) & [下](https://www.icourse163.org/course/HIT-1001527001)） - 哈尔滨工业大学 - 中国大学 MOOC
6. 丁男老师课程
