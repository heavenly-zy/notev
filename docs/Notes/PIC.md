<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css">

# PIC <Badge text="alpha" type="warn"/> <Badge text="5.1.6"/>

## 0 PIC 绪论

### 0.1 计算机系统的基本组成——“板级系统”

1. CPU 中央处理单元 指令的执行机构
2. ROM 只读存储器 只读、可通过烧录写入数据 存储程序、常数 断电不丢失
3. RAM 随机存储器 可读可写 用于存储程序运行中的变量数据或结果数据
4. BUS 总线 包括数据总线 DB、地址总线 AB、控制总线 CB
5. 外围功能模块 定时器、终端系统、IO 端口 blabla

### 0.2 计算机的构架——数据总线的结构

-  传统计算机中，各模块通过总线连接
-  其中数据总线将各个功能模块“有序”的连接，CPU 通过数据总线与 ROM、RAM、IO 设备等进行数据传输与交换

### 0.3 通用计算机的基本工作过程

1. 计算机工作过程
   1. 取指
   2. 执行
2. 执行分为：
   1. 对 RAM 进行访问
   2. 对 IO 端口的访问

## 1 PIC 微控制器的历史和特征

### 1.1 冯·诺依曼与哈弗总线结构

1. 哈弗总线：
   ROM 直接与 CPU 相连，使得取指与执行可以“同步”，而且该通路为 16bit
2. 冯·诺依曼结构：
   各模块均直接与 8bit 的 DB 相连，故速率限制在 8bit

-  哈弗总线的优点

1. 避免数据和指令共用 DB 从而使数据限制在 8bit 的瓶颈
2. 在执行一条指令时可以直接取下一条指令，使得速率可以提高进一倍
3. 增加了指令总线的宽度，使得大部分指令可以使用单字节（16bit）（双字节容易因为 PC 受干扰而发生错位，进而引发程序崩溃）
   > 为什么传统计算机不采用哈弗总线结构呢？
   > 因为传统计算机各模块是通过引脚连接到总线上的，如果要做哈弗总线的结构的话，势必使得 CPU 引脚数量加倍，但这可能要完全重新设计 CPU 的结构，因此暂时哈弗总线的计算机尚少，而单片机由于集成在一个芯片上，不需要考虑引脚的问题，故 PIC 得以采用该方式

### 1.2 低功耗

PIC 功耗很低，SLEEP 下甚至可以达到 3μA

### 1.3 I/O 端口驱动能力强

不仅能以灌电流(负逻辑)方式驱动大电流负载，还能以拉电流(正逻辑)方式驱动大电流负载

## 2 PIC 结构体与汇编语言编程

### 2.1 PIC18F452 单片机存储器配置概述

存储器：

1. ROM 32KB
2. RAM 4KB
3. EEPROM 256B（读写慢）

### 2.2 PIC18F452 单片机 RAM 概述

-  利用寄存器存放临时数据
   1. WREG 工作寄存器 1 个 8bit
      直接与 ALU 连接，是一种 SFR
   2. GPR 通用数据寄存器 组 8bit
   3. SFR 特殊功能寄存器组 若干 8bit
-  RAM 又称文件寄存器，包括 GPR 和 SFR
   1. 因为操作数最多可表示 256 个地址，故将 RAM 分为 16\*256KB（0-15 区）
   2. 在 18F 系列中，SFR 被集中在 RAM 高地址空间（15 区 80H 及之后的 128B）
   3. 跨区可以使用额外的 BSR 寄存器，可以实现 0-15 区的切换
   4. 快速访问存储区将 0 区前 128B 与 15 区后 128B（SFR）合并成一个新的 258B 的区，解决了读写 SFR 需要频繁切换区的问题

### 2.3 指令

1. MOVLW K
   将立即数 K 传送到 WREG 中
   如：

```
MOVLW 20H //向WREG中传送数据20H
```

另外只有 WREG 有权获取立即数，如果其他寄存器想获取立即数只能借助 WREG 实现
如：

```
MOVLW 08H
MOVWF 20H //向RAM的20H单元送一个数08H
```

2. ADDLW K
   对 WREG 加上一个立即数 K
   如：

```
MOVLW 20H //20H送WREG
ADDLW 30H //WREG+30H=50H,结果在WREG中
```

3. MOVF f, d, a
   将 RAM 中地址为 a 映射下的 f 的数据取出，放到 d 中

| f          | d              | a                      |
| ---------- | -------------- | ---------------------- |
| 源数据地址 | 目标容器       | 地址映射               |
| &nbsp;     | 默认 1         | 默认 0                 |
| &nbsp;     | 0:WREG</br>1:f | 0:快速访问区</br>1:BSR |

> d = 1 的意义：
> 把一个数从某地址取出来再放回该地址，可以看下该单元下的状态

如：

```
MOVF 20H, 0 //将RAM20H单元中的数据送到WREG
```

4. ADDWF f, d, a

blabla, 还有好多啦

### 2.4 状态寄存器 STATUS

#### 2.4.1 各位意义

1. **C** 进位/借位标志，是处理无符号数溢出的判定条件 （注意：减法时呈现负逻辑）
2. **DA** 辅助进位位
3. **Z** 零标志
4. **OV** 有符号数的溢出标志
5. **N** 负数标志
6. **X** 无用位

#### 2.4.2 影响 STATUS 的指令

运算肯定会影响啦，另外 MOVWF 是不影响的，而 MOVF 是影响的，这个特性使得 d=1 时可以不改变 RAM 内的该数直接看其状态（正负和是否为 0）

#### 2.4.3 标志位和判决

根据标志位进行条件转移，比如 BC 是指若 C=1 则转移，BNC 是指 C!=1 则转移，此外还有针对 Z、N、OV 位判断的指令

### 2.5 程序计数器 PC 和程序存储器 ROM

#### 2.5.1 PIC 的程序计数器

其内存储了 ROM 的地址，CPU 按照 PC 寻址，执行 ROM 该地址下的指令，PC 自动产生一个增量（18 系列单字节指令需要增 2）

#### 2.5.2 PIC18F 系列单片机 ROM 状况

0000H 是上电入口、0008H 是高优先级中断向量入口、0018H 是低优先级中断向量入口
因此 ROM 应当在 0000H 保存一条 goto 语句以跳过 0008H 与 0018H
[对 RAM、ROM 的总结](../Opinions/04_Hardware.md)

### 2.6 数据格式与伪指令

#### 2.6.1 数据格式

1. 十六进制 `B'00001111' b'00001111'`
2. 二进制 `99H 0x99 99 h'99'`
3. 十进制 `D'12' d'12' .12`
4. ASCII 码 `A'2' a'2' '2'`

#### 2.6.2 伪指令

帮助汇编器完成汇编，但并不是 ROM 内所保存的指令

1. ORG
   用于定义下面的指令或数据在 ROM 中的起始地址

```asm
ORG 0000H ;此后内容写在ROM的0000H
GOTO 0030H ;ROM内写入本语句
ORG 0030H ;此后内容写在ROM的0030H
;BLABLA
```

程序最少两个 ORG 以跳过两个中断向量

2. END
   汇编结束
3. EQU
   类似于宏啦`COUNT EQU 0x25`
4. DB、DW 伪指令
   用于在 ROM 定义常数数据，Example：

```asm
ORG 0100H
DB  00H,02H,03H,04H,05H
DB  06H,07H,08H,09H,0AH
```

## 3 分支、调用和延时循环

### 3.1 分支指令和循环

#### 3.1.1 PIC 的循环语句

1. DECFSZ f,d
   decrease file skip zero 将文件寄存器地址 f 内的数据减一放到 d 内，如果为 0 则跳过下一步
   Example

```asm
COUNT   EQU     10H
        ...     ...
        MOVLW   05H
        MOVWF   COUNT   ;COUNT=5
        MOVLW   00H
AGAIN   ADDLW   03H
        DECFSZ  COUNT,1
        GOTO    AGAIN
        MOVWF   PROTB
```

2. BNZ n;需要借助 DECF f,1 的相对跳转

### 3.2 子程序调用语句 CALL 和栈

`CALL K`
不在 RAM，有着独立栈区，32\*21bit，因为标号从 1 开始，所以 0 号栈并不能用

## 4 PIC I/O 端口编程

### 4.1 PIC18F452 的 I/O 端口

1. PORTA 7bit
2. PORTB 8bit
3. PORTC 8bit
4. PORTD 8bit
5. PORTE 3bit

### 4.2 PIC I/O 端口组成结构

1. 输出数据锁存器
2. 端口方向控制寄存器
   -  很重要的，输出要置 0（CLRF TRISx），输入要置 1（SETF TRISx）
3. 输入数据锁存器

### 4.3 I/O 端口的位操作编程

1. 位置位 BSF
2. 位清零 BCF
3. 位反转 BTG
4. 位检测 BTFSS、BTFSC

## 5 PIC 的定时器、计数器

### 5.1 TMR0

-  核心部件是二进制加一计数器

#### 5.1.1 相关 SFR

-  TMR0：16bit 结构，由两个寄存器 TMR0H 和 TMR0L 组成
-  T0CON：TMR0 的控制寄存器，设定 TMR0 的工作模式
-  INTCON：中断控制寄存器，存储 TMR0 的计数溢出标志 TMR0IF 和中断允许位 TMR0IE

#### 5.1.2 T0CON

| 位      | 状态    | 表示                                |
| ------- | ------- | ----------------------------------- |
| T0CS    | 1       | 启动定时器工作                      |
|         | 0       | 关闭定时器工作                      |
| T08BIT  | 1       | 8bit 定时/计数模式（TMR0L）         |
|         | 0       | 16bit 定时/计数模式（TMR0H、TMR0L） |
| T0CS    | 1       | 外部时钟计数——外事件**计数模式**    |
|         | 0       | 内部时钟 fosc/4 计数——**定时模式**  |
| T0SE    | 1       | 选择 T0CK1 脉冲的下降沿加一计数     |
|         | 0       | 选择 T0CK1 脉冲的上升沿加一计数     |
| PSA     | 1       | 计数脉冲不经过预分频器              |
|         | 0       | 计数脉冲经过预分频器                |
| T0PS2~0 | 000~111 | 预分频器分频比 1:2 ~ 1:256          |

#### 5.1.3 中断控制寄存器 INTCON

-  TMR0IF，计数溢出为 1
-  查询方式：位测试——TBFSS
   -  TBFSS INTCON,TMR0IF
-  中断响应方式：TMR0IF=1 时，自动引发中断

#### 5.1.4 TMR0 与初值

设置初值以满足自己所需计数和定时

#### 5.1.5 预分频器的使用

-  可以延长定时器的“定时/计数”值范围
-  使用预分频器会降低“定时/计数”的分辨率

#### 5.1.6 TMR0 的编程步骤

1. 设定 T0CON 命令字
2. 计算初值，并赋到 TMR0H、TMR0L 中
3. 使用指令`BSF T0CON,TMR0ON`启动 TMR0
4. 采用查询指令`BTFSS INTCON,TMR0IF`查询 TMR0IF 的状态，一旦 TMR0IF=1（计数溢出）进行相关操作
5. 使用指令`BCF INTCON,TMR0IF`清除标志
6. 软件重装初值（TMR0H、TMR0L）
7. 返回到步骤四，继续……

-  Example——使用定时器产生 1s 定时

   -  设 fosc=16MHz
   -  首先确定预分频器的分频比 N 以满足 1s 的定时

   $$
   T_{max} = 65536 \times 0.25\mu s \times N
   = 16.384ms \times N
   $$

   -  分频比 N 的确定：选 N=64 时

   $$
   16.384ms \times 64 = 1048.576ms > 1000ms
   $$

   -  计算初值 TC

   $$
   TC \\
   = M - \frac{T}{T_{CONUT}\times N} \\
   = 65536 - \frac{1,000,000}{0.25 \times 64} \\
   = 65536-62500 \\
   = 3036 \\
   = 0BDCH \\
   $$

   -  T0CON 的初始化

      -  TMR0ON=0：暂时不启动
      -  T08BIT=0: 16 位模式
      -  T0CS=0：定时方式
      -  T0SE=0：上升沿计数
      -  PSA=0：使用预分频器
      -  T0PS2~0=101：分频系数 1:64
         > 即 T0CON=00000101B=05H

   -  [TMR0.asm](https://github.com/SigureMo/notev/blob/master/Codes/PIC/TMR0.asm)

# Amendant Record

180913 #0 #1 Finished
180926 #2 #3 Finished
181017 #4 Finished

# Reference

1. 陈育斌老师选修课程
