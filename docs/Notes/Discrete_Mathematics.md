# Discrete Mathematics <Badge text="alpha" type="warn"/> <Badge text="3.6.2"/>

## 0 引

### 0.1 为什么要学习计算机？

我们学习计算机是为了什么？是能用一门语言写出来一个让用户满意的 APP？是创造一个 AI 模型？是利用某些框架帮助我们模拟计算？还是为了生计？

于我而言，以上都是，却也可以说全不是

#### 0.1.1 以实用性为出发点

计算机对于人类社会的发展有着巨大的推动作用，其以其极高的计算能力为我们解决了无数的难题，现在的计算机可以

-  迅速计算出很复杂的算数式，并将结果显示出来
-  将影像播放在屏幕上
-  将服务器上的 HTML 文档下载到本地，用浏览器显示出来
-  为用户推送更加适合的广告
-  等等

简单地说，计算机可以**更快、更便捷地**带给我们需要的东西，学习计算机，是为了更好地利用它来协助我们，当然，协助到什么程度，要看学到什么层次了

学习计算机，首先是能够使用自己需要的软件，帮助我们完成需要做的事，之后我们在使用过程中不断地思考计算机的运作机理，可以帮助我们解决一些运行 bug 等问题，再之后我们可以通过自己的方式进行创作，可能是熟练地使用某个软件进行一些高级操作、可能是学习一门编程语言写一些脚本协助我们工作……

然而我们当前阶段对于计算机的教育（非计算机专业）大多只是刻板的教书式，很多都是教教用些基本软件（MS Office？），然而计算机真正的操作却是越来越黑（黑匣子）了，这对于开发人员来说是一种成功，因为对于用户更加友好了，但是对于用户本身来说，离计算机却是越来越远了

#### 0.1.2 就个人兴趣而言

如果说以前的话，大概也就是一年多以前，计算机对我而言仅仅是一个黑匣子，我能看到的，仅仅是屏幕上的，我能输入的，也仅仅是手动敲一敲（那时候敲得也很慢）、鼠标点一点而已。能让我感兴趣的，大概只有电脑中的，另一个世界——游戏，而这也成为了当今大多数人的现状，虽说用着计算机，却是一点也不懂计算机（当然我那时候不如大多数人）

最初的兴趣，源于一次巧合，有幸组装了一台台式机，认识了曾经在课程中略有耳闻的各种硬件——内存条、显卡、硬盘等等，这算是与底层硬件的一次偶遇

大概半个月后，也算是一次巧合，使我产生了学习 Python 的萌芽，嗯，算是与应用层的一次偶遇

两次偶遇使我对计算机有了新的认识，并产生了浓厚的兴趣，一发不可收，进而逐渐地开始接触计算机科学知识

那么……

### 0.2 什么是计算机科学？

虽然说如今的计算机能够实现的功能五花八门，但是其本质从未改变过，那就是**计算**，那么问题来了，计算机是如何利用计算来实现现在各种各样的功能的呢？

在计算机诞生之前，就有了自动计算的相关理论，也正是这些理论催生了计算机的诞生，虽然说那个时候计算机还只是一种理想中的模型，但是其理论基础却是建立的相当完善，其中最基础的理论已经成为了一门学科，那便是离散数学

#### 0.2.1 离散数学是什么

在最近一年多有了解过一些计算机基础知识，比如有草草学过数据结构、组原、计网，也有正在学的操作系统，但是从没有这样一门学科让我能够觉得，计算机就是它，它就是计算机，而离散数学就是这样的一门学科，它从最基础的逻辑运算开始介绍，对我们真实世界的事物进行建模，形成一门理论进行推演解释

事实上，我们的计算机也正需要这样的完备的、严谨的理论支持，它可不允许有二义性的自然语言出现

#### 0.2.2 我们为什么会造出计算机

由于计算机科学的理论基础存在，我们造出的计算机注定是现在的逻辑进行运作，而不是别的样子，基础科学决定了上层模型的形态

#### 0.2.3 计算机科学会过时吗

在开始学习计算机之前我曾经担心过，量子计算机已经出现了，现在的计算机技术将来还会适用吗？现在的计算机技术是否会过时？

技术的更迭是不可避免的，说不过时是不可能的，但是令人兴奋的是，技术的更迭代表了人类社会的不断发展，但是有一点我们却是需要牢记的，我们是不断推陈出新的，新的技术是以旧的技术为基础发展而来的

当然，计算机技术依赖于计算机科学，而计算机科学本身是诞生于计算机之前的，它并不依赖于计算机的形态，计算机科学并无所谓过时与不过时，就离散数学这种基础学科而言，在任何一种计算机实现形式中，它都是基础，只不过在不同的事物上需要建立不同的模型

#### 0.2.4 计算机科学带给我们的

计算机科学本身是一门逻辑性非常强的学科，就算没有学过专业知识，稍微了解一点编程的人也能体会到其中的严谨性，写错了一个字母可能连编译都通过不了的……

此外，我们通过计算机科学了解了如何将一个真实世界的事物表现为一个严密的数学模型，并利用计算机进行求解

当然，计算机科学还有很多迷人的地方，比如在计网、组原中我们学到了某种功能的分层实现、模块化的思想等等

### 0.3 对计算机科学发展的期许……

当今时代计算机技术在迅速发展，也许计算机本身就在促进着计算机的发展吧，但无论计算机将来发展到什么程度，其本质都不会改变，我认为，我所坚持的，是对计算机科学的一种期许，大概只是因为——热爱

## 1 基础：逻辑和证明

### 1.1 命题逻辑

[python 测试脚本](https://github.com/SigureMo/notev/tree/master/Codes/DM、01_propositional_logic)

#### 1.1.1 命题

陈述句，非真即假

#### 1.1.2 逻辑运算符

-  否定 (非) $\lnot p$
-  合取 (与) $p \land q$
-  析取 (或) $p \lor q$
   -  异或 $p \oplus q$ ,与“或”不同的是，两种同时满足的情况为假，也就是二者只能选其一
-  条件语句 (蕴含) $p \to q$
   > 只有 $p$ 真 $q$ 假的情况下才为假，就像一种允诺，而 $p$ 发生后没有依诺履行 $q$ ，则其为假
   -  注意逆命题、否命题（注意，不是命题的否定）、逆否命题
-  双条件语句 (双重蕴含) $p \leftrightarrow q$
   > 即 $(p \to q) \land (q \to p)$ ，缩写 $iff$ (if and only if)，只有两者真值相同的时候为真

### 1.2 命题等价式

-  重言式（永真式）：真值永远为真
-  矛盾式：真值永远为假

#### 1.2.1 逻辑等价式

在所有情况下具有相同真值的两个复合命题等价

其定义为：

> 如果 $p \leftrightarrow q$ 是永真式，则复合命题 $p$ 和 $q$ 是逻辑等价的，记作 $p \equiv q$

-  德·摩根律
   -  $\lnot (p \lor q) \equiv \lnot p \land \lnot q$
   -  $\lnot (p \land q) \equiv \lnot p \lor \lnot q$
      > 可扩展到 $n$ 项
      >
      > -  $\lnot (\bigvee\limits_{j=1}^n p_j) \equiv \bigwedge\limits_{j=1}^n \lnot p_j$
      > -  $\lnot (\bigwedge\limits_{j=1}^n p_j) \equiv \bigvee\limits_{j=1}^n \lnot p_j$
-  $p \to q \equiv \lnot p \lor q$
-  分配律
   -  $p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$
   -  $p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$
-  吸收律
   -  $p \lor (p \land q) \equiv p$
   -  $p \land (p \lor q) \equiv p$
-  and so on... 按需查书好了

### 1.3 谓词和量词

#### 1.3.1 谓词

我们知道，$x > 3$ 不是一个语句，因为它含一个变量，我们无法判断它的真假，但是我们对 $x$ 进行赋值，我们就可以立即判断它的真假

我们将“ $>3$ ”抽取出来，这便是一个谓词

既然只要对变量赋值就可以判断真假，那么我们何不直接令其成为一个函数？这样的函数就是命题函数，也称为谓词

比如 $P(x)$ 为 $x > 3$

注意，命题函数不是命题，这个已经反复强调过了，因为它并不能判断真假

#### 1.3.2 量词

除了对命题函数进行赋值使之成为命题之外，我们使用量词也可以使之成为命题

比如

> 量词后跟其域，再之后是命题函数，如 $\forall x(x^2 \geq x)$ ，量词优先级比逻辑运算符高

-  全称量词 (任意) $\forall$

   如 $\forall x P(x)$

   -  其等价于 $\bigwedge\limits_{j=1}^n P(x_j))$
   -  $\forall x < 0 (x^2 > 0) \equiv \forall x (x < 0 \to x^2 > 0)$
   -  只要找到一个不满足就可知其为假

-  存在量词 (存在) $\exist$

   -  其等价于 $\bigvee\limits_{j=1}^n P(x_j))$
   -  $\exist z > 0 (z^2 = 2) \equiv \exist z(z > 0 \land z^2 = 2)$

-  逻辑等价式
   -  分配律
      -  $\forall x(P(x) \land Q(x)) \equiv \forall x P(x) \land \forall x Q(x)$
      -  $\exist x(P(x) \lor Q(x)) \equiv \exist x P(x) \lor \exist x Q(x)$
   -  德·摩根律
      -  $\lnot \exist x P(x) \equiv \forall x \lnot P(x)$
      -  $\lnot \forall x P(x) \equiv \exist x \lnot P(x)$
         > 否定时，论域是不变的
         >
         > $$
         >    \begin{aligned}
         >    & \lnot \exist P(x) Q(x) \\
         >    \equiv & \lnot \exist x (P(x) \land Q(x)) \\
         >    \equiv & \forall x (\lnot P(x) \lor \lnot Q(x)) \\
         >    \equiv & \forall x (P(x) \to \lnot Q(x)) \\
         >    \equiv & \forall P(x) \lnot Q(x) \\
         >    \end{aligned}
         > $$
         >
         > 另外一个很容易证明，此处不作赘述

#### 1.3.3 嵌套量词

一个量词出现在另一个量词的作用域内，如 $\forall x \exist y (x + y = 0)$

**除非都是全称量词或者全是存在量词，否则顺序不可交换**

但是我们可以将量词提前，如 $\forall x ((F(x) \land P(x)) \to \exist y M(x, y)) \equiv \forall x \exist y ((F(x) \land P(x)) \to M(x, y))$

-  例，用量词表示极限定义（$\lim\limits_{x \to a} f(x) = L$）“对每个实数 $\varepsilon > 0$ ，存在一个实数 $\delta > 0$ ，使得对任意的 $x$ ，只要 $0 < |x-a| < \delta$，就有 $|f(x) - L| < \varepsilon$”
   -  $\forall \varepsilon > 0 \exist \delta > 0 \forall x (0 < |x-a| < \delta \to |f(x) - L| < \varepsilon)$
   -  即 $\forall \varepsilon \exist \delta \forall x (0 < |x-a| < \delta \to |f(x) - L| < \varepsilon)$

否定的话，逐层使用德·摩根律就好

### 1.4 推理规则

我们已经可以知道某个命题是真假，但是我们如何通过一个或者多个命题推断出新的命题的真假呢？

#### 1.4.1 命题逻辑的有效论证

当我们有条件 $p_1\ p_2\ p_3\ \cdots\ p_n$ 的时候，如何推理出结论 $q$ 为真？

很明显，我们让在所有前提的发生的时候，结论永远为真即可，也就是 $(\bigwedge\limits_{j=1}^n p_j) \to q$ 是永真式的情况下，该论证形式是有效的

#### 1.4.2 命题逻辑的推理规则

如何判定一个式子是永真式？某些式子我们可以记住，但是真实情况下有很多式子并没有对应的用来套用，那难道我们要去用真值表吗？

本节先介绍我们需要记住的一些式子，下节介绍如何根据已有式子推出更加复杂的式子

| 名称       | 永真式                                               | 逻辑解释                                                                               |
| ---------- | ---------------------------------------------------- | -------------------------------------------------------------------------------------- |
| 假言推理   | $(p \land (p \to q)) \to q$                          | 已知在发生前提 $p$ 时必发生结果 $q$ ，并且前提 $p$ 发生了，所以结果 $q$ 一定会发生     |
| 取拒式     | $(\lnot q \land (p \to q)) \to \lnot p$              | 已知在发生前提 $p$ 时必发生结果 $q$ ，但是结果 $q$ 并没有发生，所以前提 $p$ 一定没发生 |
| 假言三段论 | $((p \to q) \land (q \to r)) \to (p \to r)$          | 已知发生前提 $p$ 时必发生 $q$，且发生 $q$ 时必发生 $r$ ，故发生 $p$ 时必发生 $r$       |
| 析取三段论 | $((p \lor q) \land \lnot p) \to q$                   | 已知 $p$ 和 $q$ 至少发生了一个，并且 $p$ 没发生，那么 $q$ 必然发生                     |
| 附加律     | $p \to (p \lor q)$                                   | 已知 $p$ 发生了，那么当然 $p$ 和 $q$ 之中至少发生一件是对的了                          |
| 化简律     | $(p \land q) \to p$                                  | 已知 $p$ 和 $q$ 都发生了，那么 $p$ 当然发生了                                          |
| 合取律     | $((p) \land (q)) \to (p \land q)$                    | 已知 $p$ 发生了， $q$ 也发生了， 所以说 $p$ 和 $q$ 都发生了自然是对的                  |
| 消解律     | $((p \lor q) \land (\lnot p \lor r)) \to (q \lor r)$ | 不太好表述啊……                                                                         |

#### 1.4.3 使用推理规则建立论证

比如我们想从 $\lnot p \land q$ 、 $r \to p$ 、 $\lnot r \to s$ 、 $s \to t$ 推出结论 $t$ ，要如何做到呢？

1. $\lnot p \land q$ ，前提引入
2. $\lnot p$ ， 化简律，用 (1)
3. $r \to p$ ， 前提引入
4. $\lnot r$ ， 取拒式，用 (2)(3)
5. $\lnot r \to s$ ，前提引入
6. $s$ ， 假言推理，用 (4)(5)
7. $s \to t$ ，前提引入
8. $t$ ，假言推理，用 (6)(7)

#### 1.4.4 量化命题的推理规则

| 名称     | 推理规则                                                    |
| -------- | ----------------------------------------------------------- |
| 全称实例 | $\forall x P(x) \to P(c)$                                   |
| 全称引入 | $P(c) \to \forall x P(x)$ ，其中 $c$ 为任意值才能得出该结论 |
| 存在实力 | $\exist x P(x) \to P(c)$                                    |
| 存在引入 | $P(c) \to \exist x P(x)$                                    |

### 1.5 证明

如何得知一个语句的真实性？

#### 1.5.1 直接证明法

如何证明条件语句 $p \to q$ ？首先假设 $p$ ，通过推理得到 $q$ ，那么 $p \to q$ 为真

#### 1.5.2 反证法

基于条件语句逆反命题等价于自身的性质，即要证 $p \to q$ 先证 $\lnot q \to \lnot p$

> -  空证明 证明 $p$ 为假即可知 $p \to q$ 为真
> -  平凡证明 证明 $q$ 为真即可知 $p \to q$ 为真

#### 1.5.3 归谬证明法

我们要证 $p$ 为真，可以通过找一个矛盾式 $q$ 使得 $\lnot p \to q$ 为真，因为 $q$ 为假，则 $\lnot p$ 为假，即 $p$ 为真

由于 $r \land \lnot r$ 是显然的矛盾式，所以经常使用其作为上式中的 $q$

#### 1.5.4 等价证明法

要证 $p \leftrightarrow q$ 可证 $(p \to q) \land (q \to p)$

一般地，要证 $p_1 \leftrightarrow p_2 \leftrightarrow p_3 \leftrightarrow \cdots \leftrightarrow p_n$ 可证 $(p_1 \to p_2) \land (p_2 \to p_3) \land \cdots \land (p_n \to p_1)$ ，只需要形成这样一个全串起来的环就行，不需要任何两个之间都证一遍

#### 1.5.5 穷举证明法和分情形证明法

均基于 $[(p_1 \lor p_2 \lor p_3 \lor \cdots \lor p_n) \to q] \leftrightarrow [(p_1 \to q) \land (p_2 \to q) \land \cdots \land (p_n \to q)]$ 是重言式，将 $p$ 分为 $p_1 \lor p_2 \lor \cdots \lor p_n$ ，即将其论域分为多个子论域，当然，这些个子论域包含了所有的情况

-  穷举论证法 将有穷的情况一一列出，并分别证明
-  分情形证明法 当整个论域不方便一起证明时，可将论域分割成一个个比较方便证明的子论域，一一证明

另外，值得注意的一点是，我们可以通过不失一般性对证明过程进行简化，比如在一个可以互换 $x$ 和 $y$ 的式子中，如果我们已经证明过 $x$ ，那么我们可以知道 $y$ 也是一样的

#### 1.5.6 存在性证明

-  构造性的 通过找到这样一个实例来说明这样的实例是存在的
-  非构造性的 并不是真正的找出这样的实例，而是通过证明得出这样的实例真的存在

#### 1.5.7 唯一性证明

1. 存在 $x$ 具有该性质
2. 任何其他不是 $x$ 的都没有这个性质

#### 1.5.8 寻找反例

通过寻找反例来证明一个语句是假的

#### 1.5.9 证明策略实践

> 当数学家相信猜想可能是真的时，他们会尝试寻找证明。如果他们找不到证明，他们就会寻找反例。当他们寻找不到反例时，他们又会转回来再次试图证明猜想。
>
> <div style="text-align: right"> ——《离散数学及其应用》 1.8.7 证明策略实践</div>

## 2 基本结构：集合、函数、序列、求和与矩阵

### 2.1 集合

> 空集 $\varnothing$

#### 2.1.1 集合的表示方法

-  花名册方法 如 $V = \{1, 2, 3, 4, 5\}$
-  集合构造器 如 $O = \{x \in R | x = p / q, p \in N^+, q \in N^+\}$

#### 2.1.2 子集

$A \subseteq B$ 当且仅当 $\forall x (x \in A \to x \in B)$

-  每个非空集合 $S$ 都至少有两个子集，空集和集合 $S$ 本身
-  证明两个集合 $A$ 和 $B$ 相等，就证明 $A \subseteq B$ 和 $B \subseteq A$

#### 2.1.3 集合的大小

集合 $S$ 的基数 $|S|$ ，为集合中的元素数

#### 2.1.4 幂集

集合 $S$ 中所有子集的集合，记作 $P(S)$

如果一个集合有 $n$ 个元素，那么它的幂集就有 $2^n$ 个元素

#### 2.1.5 笛卡尔积

-  有序 $n$ 元组：区别于集合，是一种有序的结构，表示为 $(a_1, a_2, \cdots , a_n)$
-  序偶： 有序二元组

笛卡尔积：所有序偶 $(a, b)$ 的集合，其中 $a \in A$ 且 $b \in B$ ，即

$$
A \times B = \{ (a, b) | a \in A \land b \in B\}
$$

笛卡尔积可以用来表示两个集合之间的关系，比如集合 $A$ 为一所大学所有学生的集合，集合 $B$ 为该大学开设的所有课程的集合，则两学校的笛卡尔积可以表示该校学生的选课的所有情况

-  $A \times B \not = B \times A$
-  $A^2 = A \times A$
-  笛卡尔积 $A \times B$ 的一个子集称为集合 $A$ 到 $B$ 之间的一个关系，沿用上例，可以理解为某些学生选了某些课

#### 2.1.6 真值集和量词

-  论域 $D$ 下，谓词 $P$ 的真值集为 $\{ x \in D | P(x) \}$
-  全称 $\forall x \in S (P(x))$
-  存在 $\exist x \in S (P(x))$

### 2.2 集合运算

#### 2.2.1 基本运算

-  并 $A \cup B = \{ x | x \in A \lor x \in B \}$
   > $\bigcup \limits_{i = 1}^n = A_1 \cup A_2 \cup \cdots \cup A_n$
-  交 $A \cup B = \{ x | x \in A \land x \in B \}$
   -  $|A \cup B| = |A| + |B| - |A \cap B|$
      > $\bigcap \limits_{i = 1}^n = A_1 \cap A_2 \cap \cdots \cap A_n$
-  差 $A - B = \{ x | x \in A \land x \notin B \}$
   -  $A - B = A \cap \overline{B}$
-  补 $A \cup B = \{ x \in U | x \notin A \}$
   -  $\overline{A} = U - A$

#### 2.2.2 集合恒等式

-  分配律
   -  $A \cup (B \cap C) = (A \cap B) \cup (A \cap C)$
   -  $A \cap (B \cup C) = (A \cup B) \cap (A \cup C)$
-  德·摩根律
   -  $\overline{A \cap B} = \overline{A} \cup \overline{B}$
   -  $\overline{A \cup B} = \overline{A} \cap \overline{B}$

如何证明恒等式？

-  直接证明法 证明 $A \subseteq B$ 并且 $B \subseteq A$ “即可”
-  集合构造器 始终使用集合构造器表示集合，辅之以逻辑运算，得到要的式子
-  成员表 类似于真值表，列出各个元素是否属于该集合

#### 2.2.3 集合的计算机表示

可用位串来表示 $U$ 的子集 $A$，如果元素 $a_i \in A$ ，则第 $i$ 位为 1 ，否则为 0 ，这样可以很方便地实现交并补操作（按位与、或、非）

### 2.3 函数

#### 2.3.1 定义

如果对每一个元素 $a \in A$ 都有且仅有一个序偶 $(a, b)$ ，则它就定义了 $A$ 到 $B$ 的一个函数 $f$

-  定义域 原像 $a$ 的集合
-  值域 像 $b$ 的集合
-  陪域 $B$

> -  值域只是陪域的一部分（子集）
> -  如果改变函数的定义域或陪域，那么将得到一个不同的函数，如果改变元素的映射关系，也会得到一个不同的函数

#### 2.3.2 一对一、映上、一一对应

-  一对一函数（单射函数）

   不允许多个原像对应同一个像

-  映上函数（满射函数）

   值域等于陪域

-  一一对应函数（双射函数）

   既是一对一的，又是映上的

#### 2.3.3 反函数

一一对应才有反函数，故一一对应关系又称为可逆的

-  定义函数的合成 $f \circ g $ ，$(f \circ g)(a) = f(g(a))$
-  $f^{-1} \circ f = \iota_A$ ， $f \circ f^{-1} = \iota_B$ ，$(f^{-1})^{-1} = f$
   > $\iota(x) = x$

#### 2.3.4 函数的图

$A \times B$ 中各个序偶集合，可以画出来帮助理解

#### 2.3.5 一些重要的函数

-  向下取整 $\lfloor x \rfloor$
-  向上取整 $\lceil x \rceil$
-  阶乘函数 $n!$

### 2.4 序列与求和

序列的项的显式公式称为闭公式

常用序列

-  几何级数
-  算数级数

### 2.5 集合的基数

#### 2.5.1 定义

有限集的基数很简单，就是元素的个数，那么无限集呢？

对于无限集，我们可以定义他们之间的相对大小，但并不能定义他们之间的大小

如果存在一个从 $A$ 到 $B$ 之间的一个一一对应函数，那么他们有相同的基数，即 $|A| = |B|$

相似地，如果存在从 $A$ 到 $B$ 之间的一个一对一函数，那么 $|A| \leq |B|$

#### 2.5.2 可数集

一个集合或者**是有限集**或者**与自然数集具有相同的基数**，这个集合就称为可数的

如果一个无限集 $S$ 是可数的，我们用符号 $\alef_0$ 表示集合 $S$ 的基数 $|S|$

-  无限集是可数的当且仅当可以把集合中的元素排列成序列（下标是**正整数**）
-  我们可以得出几个结论：
   -  有理数集是可数的
   -  无理数集是不可数的
-  如果 $A$ 和 $B$ 是可数集合，则 $A \cup B$ 也是可数集合

#### 2.5.3 不可计算函数的存在性

如果存在某种编程语言写的计算机程序能计算一个函数的值，那么这个函数称为是可计算的

-  首先，任何编程语言写的计算机程序的集合是可数的
-  其次，存在不可数无限多个不同的从一个特定的可数无限集到自身的函数
-  所以，能写出来的函数是不足以满足所有的问题的，即存在不可计算的函数

### 2.6 矩阵

这里注意下 $0-1$ 矩阵即可，其他的在线代就学过了

-  $0-1$ 矩阵的并 $\lor$ ，即逐项逻辑与
-  $0-1$ 矩阵的交 $\land$ ，即逐项逻辑并
-  $0-1$ 矩阵的布尔积 $\odot$ ，与矩阵乘法类似，各项的乘号换成 $\land$ （逻辑乘），各结果的加号换成 $\lor$ （逻辑和）
-  $0-1$ 矩阵的布尔幂 $A^{[r]}$ ，就是布尔积 $r$ 次

## 3 计数

### 3.1 计数的基础

-  乘积法则
-  求和法则
-  减法法则 两个集合的容斥原理
-  除法法则

### 3.2 鸽巢原理

如果 $k + 1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 $2$ 个或更多的物体

如果广义化，可以得到广义鸽巢原理如下：

如果 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子包含了至少 $\lceil N/k \rceil$ 个物体

由广义鸽巢定理，我们可以得到以下定理

每个由 $n^2 + 1$ 个不同实数构成的序列都包含一个长为 $n + 1$ 的严格递增子序列或严格递减子序列

### 3.3 排列与组合

-  排列 $A_n^m$
-  组合 $C_n^m$

### 3.4 二项式系数和恒等式

#### 3.4.1 二项式定理

$$
(x + y)^n = \sum_{j = 0}^n C_n^j x^{n-j} y^j
$$

令 $x = 1, y = 1$ 可得推论

$$
\sum_{j = 0}^n C_n^k = 2^n
$$

类似的，还可得到一些其它推论，不作赘述

#### 3.4.2 帕斯卡恒等式

$$
C_{n + 1}^k = C_n^{k - 1} + C_n^k
$$

### 3.5 排列与组合的推广

-  有重复的排列

   具有 $n$ 个对象的集合运行重复的 $r$ 排列数是 $n^r$

-  有重复的组合

   $n$ 个元素的集合中允许重复的 $r$ 组合有 $C_{n + r - 1}^r$ 个

-  等等等等，具体问题具体分析即可，对问题的探索过程可以参考书上内容（我才不会说是因为我懒得打了呢）

### 3.6 生成排列与组合

既然我们已经排列与组合都有多少种了，可是我们如何去求解分别是哪些种呢？有没有专门的算法进行求解呢？

#### 3.6.1 生成排列

首先将原有元素从 $1$ 到 $n$ 进行排列，作为原始的字典顺序，之后按照该顺序进行生成后续顺序

#### 3.6.2 生成组合

使用位串对元素进行标记，计算位串的顺序，据此生成组合

# Reference

1. 《离散数学及其应用》 Kenneth H. Rosen
