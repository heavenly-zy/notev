# Encoding
## 1 初识
任何数据在计算机看来都是二进制01组成的代码，所以，为了能将数据存储，就必须转换成二进制的数据，这其中的规则便是编码。

## 2 进制与编码
今天看了下《计算机科学导论》前几章，突然想到进制数与之前总结的Python的字符编码是那么的相似，再想了一下，貌似这个便是编码的雏形呀，故对本文内容进行了重构，将本篇扩展到编码，面向所有语言与类型。

### 2.1 十进制与二进制
十进制我们最为熟悉了，我们使用0-9九个数字将所有的数字表示了出来，至于为什么是十进制，有人说是因为人有十根手指，不过这都没关系啦，我们只需要知道我们使用起来很方便就好啦。

虽然我们使用起来很方便，但是机器可不是那么方便地使用的，机器需要使用状态来表示我们所知道的数字，但是机器可没有这么多稳定的状态，唯有两个状态是相对稳定的——高电平与低电平，也就可以表示两个数字0和1，而要想用这两个数字表示所有的数，就是二进制的规则了。

因为最终表示的都是数，所以二进制与十进制本质上的一样的，也就是使用某些符号表示所有的数字，**如果我们把这个过程抽象成几种符号到某个空间的映射，那么这个映射的规则便是编码**，在这里表现为进制转换。我们不能说十进制表示的是我们要的数而二进制就不是，也不能说二进制表示的是而十进制不是，他们都有着完整的映射关系，他们表示的都是我们想要的数，而我们想要的数自然也不是所谓的十进制，仅仅只是我们抽象概念里的那么几个数，十进制二进制不过是他的表现而已。

### 2.2 具体与抽象
上面的听上去很是拗口，但是确实是这样呀，我们总是想把抽象的事物表示为具体的事物，而**具体向抽象总有一个映射关系，这样的映射关系可能完全，可能只是进行部分的表征**，如果不能完全的表示，就会造成数据的部分损失，这就导致我们存在某些不能描述的部分，这有点类似于低维空间无法解释高维空间，如果一定要解释的话总会有些东西是无法看到的，如果一定要“看到”，只能通过想象，比如通过几张二维图画想象三维空间，这对于二维空间只能是抽象的概念了。

### 2.3 机器的认知
我们人类本身有着众多神经元与完整的机体帮助我们认识世界，我们可以直接感觉到的有着各种各样的元素，比如听觉嗅觉等等，而且我们还可以感知他们的强度等等，这对于机器来说完全是无法想象的，**因为到现在为止，他们还只能感知0和1**，除非他们在某种程度上组成了某种机体，当然这是后话了。这里要说的是，我们所认知的世界对于机器来说是完全抽象的，我们怎么可以妄想使用0和1表征这么大的数据量，但是机器现阶段所要完成的任务也并不是代替人类，只是辅助人类而已，所以我们可以使用某种映射让机器来“理解”部分我们所认识的真实空间，至于怎么用0和1来表示这些是一直以来都要解决的问题。

## 3 Character Encoding
这里使用Python中的字符表示作为例子进行讲解
### 3.1 ASCII -> Unicode -> UTF-8
既然要说字符编码，那么……就从字符编码的发展讲起吧。
1. ASCII

在字符编码内首先出现的便是ASCII码了，它存储了128个基本字符，仅需要1byte的数据，基本对应键盘上的大部分字符。

2. 各种标准

很明显，我们在ASCII中找不到我们想要的中文字符，当然，中文也不是128个所能容纳的，那么我们就需要有其他的字符编码。所以就中文而言有了’GB2312’这样的编码，同样地，其他国家也有自己的字符编码。这样问题就来了，因为编码规则不同，所以一个码可能对应多个字符，通过不同编码方式解码出来的文字完全不一样，这样的话就会出现我们常说的乱码问题，而且，同一文章也无法兼容两种文字。

3. Unicode

为了统一这一标准Unicode应运而生。Unicode是在ASCII编码的基础上进行了扩展，对ASCII兼容，也即，ASCII码的字符的Unicode码是在其基础上加1byte的0，（这1byte的0便是’’（空字符）啦，所以ASCII解码时候完全不影响哒），Unicode采用2byte数据存储，完美解决了各国标准不一的问题。

4. UTF-8

但是另一个问题就产生了，就是上面所说的，ASCII码对应的字符是要两倍的数据，造成了资源的极大浪费（毕竟英语还是使用最广泛的语言啊），因此便有了我们现在最常用的UTF-8编码。UTF-8编码采用1-3byte数据存储字符，ASCII对应那些字符依然只需要1byte，中文等字符采用2-3byte的编码，使资源得到了极大的节约。因此我们在文件中在的字符采用utf-8编码以节省空间，但当我们读取他们的时候，就会重新编码为Unicode码存到内存中，当我们保存它的时候又会编码为utf-8码存到硬盘上。

### 3.2 Python Encoding
编码（encode）和解码（decode）的问题困扰了我很久，但把之前学的基础知识梳理一遍后就有了新的发现。首先，任何字符串都一定有一个编码规则，不然这个字符串是不会被计算机所认识的，我们在python中的字符是以Unicode编码存储的，也就是说任何存储在python内存的字符都是以Unicode码形式存储的，每个字符都对应一个Unicode码，就比如说’\u6587’是完全等价于’文’的：
```Python
>>> '\u6587'#后面四位是四个十六进制数，刚好是Unicode码对应的2byte（一个16进制数相当于4个2进制数，也即4bit，2byte需要4个16进制数）
'文'
```
而且，我们也可以用chr(),ord()函数将字符进行与Unicode码的互相转换：
```Python
>>> chr(25991)#十进制的25991对应十六进制数就是6587
'文'
```
当然，python也只是用Unicode码存储str，我们的str还是str，并不是一个bytes，想要将它变成一个bytes就需要调用encode方法：
```Python
>>> '文'.encode('utf-8')
b'\xe6\x96\x87' #bytes类型，编码之后对应的字节流，’\x??’是转义为16进制数，每个1byte，一共3byte
```
encode方法是将一个str按照编码方式转化成bytes，这个bytes是我们所看不懂的，但却是文件传输时候所需要的，当我们想要把它再变回str时候是一定要按原来编码方式进行decode，不然就会乱码甚至引发无法解码的错误：
```Python
b'\xe6\x96\x87'.decode('GB2312')
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    b'\xe6\x96\x87'.decode('GB2312')
UnicodeDecodeError: 'gb2312' codec can't decode byte 0xe6 in position 0: illegal multibyte sequence
>>> b'\xe6\x96\x87'.decode('utf8')#这里不区分utf8 utf-8的（大小写也都行）
'文'
```
在spider实战过程中遇到了不少编码问题，刚开始还经常将decode和encode弄混，下面记录下遇到的编码问题：
1.	bs4库：把修改bs4对象encoding属性当做之后会对其进行encode，后来才明白原来只是申明编码方式，事实上还是将HTML页面（bytes）进行decode，这样才得到我们所能看到的页面，如果申明的编码方式错误便会出现乱码甚至无法decode的情况。
2.	emoji的处理问题：当时是直接复制过来的，后来才明白是将无法解码的bytes过滤，这样就不会报错了。
```Python
non_bmp_map = dict.fromkeys(range(0x10000, sys.maxunicode + 1), 0xfffd)
r.text.translate(non_bmp_map)#r.text是待解析的str
```
3.	解析页面时候遇到“不间断空白符&nbsp”无法解码的问题：将HTML中获得的str中的该字符进行替换
s.string.replace(u'\xa0',u' ')#s.string是待替换文本

### 3.3 进制与字符编码
前面铺垫了那么多，就是为了说明下Python里的字符表示。首先我们已经知道，进制的话，就是是我们有几个符号，想要用他们表示整个数字空间，我们创造了十进制、二进制甚至六十进制，他们都将整个数字空间表示了出来，但是我们常用的还是十进制。

Python里面的字符嘛，就是想用0和1表示整个字符空间，一方面要考虑使用的数据长度，另一方面要考虑到是否能完整映射。ASCII、gbk、gb2312很明显是不完全映射，utf-8、Unicode在某种程度上映射了所有的字符，我们可以放心地使用他们，但是Unicode就像数制里的十进制一样，是一个广泛使用的编码规则，所以Python里面采用它作为str默认编码，但我们可不能说Unicode就是我们要表示的字符，因为Unicode只是一串01字节流啊，它只是机内的一种表示方法罢了，而真正的字符，是抽象的。

# Amendant Record
1. 180518 Init
2. 180909 Change #1
3. 181009 Add #2 Rename #1_to_#3

# Reference
1. [廖雪峰 Python教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000)  
2. 《计算机科学导论（第三版）》 佛罗赞